export declare const CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment: {
    readonly Warn: "Warn";
    readonly Enforce: "Enforce";
};
/**
 * Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
 */
export type CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment = (typeof CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment)[keyof typeof CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment];
export declare const EventSourceMappingDocumentDbEventSourceConfigFullDocument: {
    readonly UpdateLookup: "UpdateLookup";
    readonly Default: "Default";
};
/**
 * Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
 */
export type EventSourceMappingDocumentDbEventSourceConfigFullDocument = (typeof EventSourceMappingDocumentDbEventSourceConfigFullDocument)[keyof typeof EventSourceMappingDocumentDbEventSourceConfigFullDocument];
export declare const EventSourceMappingFunctionResponseTypesItem: {
    readonly ReportBatchItemFailures: "ReportBatchItemFailures";
};
export type EventSourceMappingFunctionResponseTypesItem = (typeof EventSourceMappingFunctionResponseTypesItem)[keyof typeof EventSourceMappingFunctionResponseTypesItem];
export declare const EventSourceMappingMetricsConfigMetricsItem: {
    readonly EventCount: "EventCount";
};
export type EventSourceMappingMetricsConfigMetricsItem = (typeof EventSourceMappingMetricsConfigMetricsItem)[keyof typeof EventSourceMappingMetricsConfigMetricsItem];
export declare const EventSourceMappingSourceAccessConfigurationType: {
    readonly BasicAuth: "BASIC_AUTH";
    readonly VpcSubnet: "VPC_SUBNET";
    readonly VpcSecurityGroup: "VPC_SECURITY_GROUP";
    readonly SaslScram512Auth: "SASL_SCRAM_512_AUTH";
    readonly SaslScram256Auth: "SASL_SCRAM_256_AUTH";
    readonly VirtualHost: "VIRTUAL_HOST";
    readonly ClientCertificateTlsAuth: "CLIENT_CERTIFICATE_TLS_AUTH";
    readonly ServerRootCaCertificate: "SERVER_ROOT_CA_CERTIFICATE";
};
/**
 * The type of authentication protocol, VPC components, or virtual host for your event source. For example: ``"Type":"SASL_SCRAM_512_AUTH"``.
 *   +   ``BASIC_AUTH`` – (Amazon MQ) The ASMlong secret that stores your broker credentials.
 *   +   ``BASIC_AUTH`` – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
 *   +   ``VPC_SUBNET`` – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
 *   +   ``VPC_SECURITY_GROUP`` – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.
 *   +   ``SASL_SCRAM_256_AUTH`` – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
 *   +   ``SASL_SCRAM_512_AUTH`` – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
 *   +   ``VIRTUAL_HOST`` –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
 *   +   ``CLIENT_CERTIFICATE_TLS_AUTH`` – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
 *   +   ``SERVER_ROOT_CA_CERTIFICATE`` – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
 */
export type EventSourceMappingSourceAccessConfigurationType = (typeof EventSourceMappingSourceAccessConfigurationType)[keyof typeof EventSourceMappingSourceAccessConfigurationType];
export declare const FunctionArchitecturesItem: {
    readonly X8664: "x86_64";
    readonly Arm64: "arm64";
};
export type FunctionArchitecturesItem = (typeof FunctionArchitecturesItem)[keyof typeof FunctionArchitecturesItem];
export declare const FunctionLoggingConfigApplicationLogLevel: {
    readonly Trace: "TRACE";
    readonly Debug: "DEBUG";
    readonly Info: "INFO";
    readonly Warn: "WARN";
    readonly Error: "ERROR";
    readonly Fatal: "FATAL";
};
/**
 * Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
 */
export type FunctionLoggingConfigApplicationLogLevel = (typeof FunctionLoggingConfigApplicationLogLevel)[keyof typeof FunctionLoggingConfigApplicationLogLevel];
export declare const FunctionLoggingConfigLogFormat: {
    readonly Text: "Text";
    readonly Json: "JSON";
};
/**
 * The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
 */
export type FunctionLoggingConfigLogFormat = (typeof FunctionLoggingConfigLogFormat)[keyof typeof FunctionLoggingConfigLogFormat];
export declare const FunctionLoggingConfigSystemLogLevel: {
    readonly Debug: "DEBUG";
    readonly Info: "INFO";
    readonly Warn: "WARN";
};
/**
 * Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
 */
export type FunctionLoggingConfigSystemLogLevel = (typeof FunctionLoggingConfigSystemLogLevel)[keyof typeof FunctionLoggingConfigSystemLogLevel];
export declare const FunctionPackageType: {
    readonly Image: "Image";
    readonly Zip: "Zip";
};
/**
 * The type of deployment package. Set to ``Image`` for container image and set ``Zip`` for .zip file archive.
 */
export type FunctionPackageType = (typeof FunctionPackageType)[keyof typeof FunctionPackageType];
export declare const FunctionRecursiveLoop: {
    readonly Allow: "Allow";
    readonly Terminate: "Terminate";
};
/**
 * The function recursion configuration.
 */
export type FunctionRecursiveLoop = (typeof FunctionRecursiveLoop)[keyof typeof FunctionRecursiveLoop];
export declare const FunctionRuntimeManagementConfigUpdateRuntimeOn: {
    readonly Auto: "Auto";
    readonly FunctionUpdate: "FunctionUpdate";
    readonly Manual: "Manual";
};
/**
 * Specify the runtime update mode.
 *   +   *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.
 *   +   *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
 *   +   *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
 *
 *   *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
 */
export type FunctionRuntimeManagementConfigUpdateRuntimeOn = (typeof FunctionRuntimeManagementConfigUpdateRuntimeOn)[keyof typeof FunctionRuntimeManagementConfigUpdateRuntimeOn];
export declare const FunctionSnapStartApplyOn: {
    readonly PublishedVersions: "PublishedVersions";
    readonly None: "None";
};
/**
 * Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
 */
export type FunctionSnapStartApplyOn = (typeof FunctionSnapStartApplyOn)[keyof typeof FunctionSnapStartApplyOn];
export declare const FunctionSnapStartResponseApplyOn: {
    readonly PublishedVersions: "PublishedVersions";
    readonly None: "None";
};
/**
 * When set to ``PublishedVersions``, Lambda creates a snapshot of the execution environment when you publish a function version.
 */
export type FunctionSnapStartResponseApplyOn = (typeof FunctionSnapStartResponseApplyOn)[keyof typeof FunctionSnapStartResponseApplyOn];
export declare const FunctionSnapStartResponseOptimizationStatus: {
    readonly On: "On";
    readonly Off: "Off";
};
/**
 * When you provide a [qualified Amazon Resource Name (ARN)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using), this response element indicates whether SnapStart is activated for the specified function version.
 */
export type FunctionSnapStartResponseOptimizationStatus = (typeof FunctionSnapStartResponseOptimizationStatus)[keyof typeof FunctionSnapStartResponseOptimizationStatus];
export declare const FunctionTracingConfigMode: {
    readonly Active: "Active";
    readonly PassThrough: "PassThrough";
};
/**
 * The tracing mode.
 */
export type FunctionTracingConfigMode = (typeof FunctionTracingConfigMode)[keyof typeof FunctionTracingConfigMode];
export declare const PermissionFunctionUrlAuthType: {
    readonly AwsIam: "AWS_IAM";
    readonly None: "NONE";
};
/**
 * The type of authentication that your function URL uses. Set to ``AWS_IAM`` if you want to restrict access to authenticated users only. Set to ``NONE`` if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
 */
export type PermissionFunctionUrlAuthType = (typeof PermissionFunctionUrlAuthType)[keyof typeof PermissionFunctionUrlAuthType];
export declare const UrlAllowMethodsItem: {
    readonly Get: "GET";
    readonly Put: "PUT";
    readonly Head: "HEAD";
    readonly Post: "POST";
    readonly Patch: "PATCH";
    readonly Delete: "DELETE";
    readonly Asterisk: "*";
};
export type UrlAllowMethodsItem = (typeof UrlAllowMethodsItem)[keyof typeof UrlAllowMethodsItem];
export declare const UrlAuthType: {
    readonly AwsIam: "AWS_IAM";
    readonly None: "NONE";
};
/**
 * Can be either AWS_IAM if the requests are authorized via IAM, or NONE if no authorization is configured on the Function URL.
 */
export type UrlAuthType = (typeof UrlAuthType)[keyof typeof UrlAuthType];
export declare const UrlInvokeMode: {
    readonly Buffered: "BUFFERED";
    readonly ResponseStream: "RESPONSE_STREAM";
};
/**
 * The invocation mode for the function's URL. Set to BUFFERED if you want to buffer responses before returning them to the client. Set to RESPONSE_STREAM if you want to stream responses, allowing faster time to first byte and larger response payload sizes. If not set, defaults to BUFFERED.
 */
export type UrlInvokeMode = (typeof UrlInvokeMode)[keyof typeof UrlInvokeMode];
