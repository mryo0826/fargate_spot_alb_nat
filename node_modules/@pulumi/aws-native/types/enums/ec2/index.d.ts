export declare const CapacityReservationFleetInstanceMatchCriteria: {
    readonly Open: "open";
};
/**
 * Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria.
 *
 * Currently, Capacity Reservation Fleets support `open` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
 */
export type CapacityReservationFleetInstanceMatchCriteria = (typeof CapacityReservationFleetInstanceMatchCriteria)[keyof typeof CapacityReservationFleetInstanceMatchCriteria];
export declare const CapacityReservationFleetTenancy: {
    readonly Default: "default";
};
/**
 * Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
 *
 * - `default` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
 * - `dedicated` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
 */
export type CapacityReservationFleetTenancy = (typeof CapacityReservationFleetTenancy)[keyof typeof CapacityReservationFleetTenancy];
export declare const Ec2FleetCapacityRebalanceReplacementStrategy: {
    readonly Launch: "launch";
    readonly LaunchBeforeTerminate: "launch-before-terminate";
};
/**
 * The replacement strategy to use. Only available for fleets of type `maintain` .
 *
 * `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
 *
 * `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
 */
export type Ec2FleetCapacityRebalanceReplacementStrategy = (typeof Ec2FleetCapacityRebalanceReplacementStrategy)[keyof typeof Ec2FleetCapacityRebalanceReplacementStrategy];
export declare const Ec2FleetCapacityReservationOptionsRequestUsageStrategy: {
    readonly UseCapacityReservationsFirst: "use-capacity-reservations-first";
};
/**
 * Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
 *
 * If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).
 *
 * If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
 */
export type Ec2FleetCapacityReservationOptionsRequestUsageStrategy = (typeof Ec2FleetCapacityReservationOptionsRequestUsageStrategy)[keyof typeof Ec2FleetCapacityReservationOptionsRequestUsageStrategy];
export declare const Ec2FleetExcessCapacityTerminationPolicy: {
    readonly Termination: "termination";
    readonly NoTermination: "no-termination";
};
/**
 * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
 *
 * Supported only for fleets of type `maintain` .
 */
export type Ec2FleetExcessCapacityTerminationPolicy = (typeof Ec2FleetExcessCapacityTerminationPolicy)[keyof typeof Ec2FleetExcessCapacityTerminationPolicy];
export declare const Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem: {
    readonly AmazonWebServices: "amazon-web-services";
    readonly Amd: "amd";
    readonly Habana: "habana";
    readonly Nvidia: "nvidia";
    readonly Xilinx: "xilinx";
};
export type Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem];
export declare const Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem: {
    readonly A10g: "a10g";
    readonly A100: "a100";
    readonly H100: "h100";
    readonly Inferentia: "inferentia";
    readonly K520: "k520";
    readonly K80: "k80";
    readonly M60: "m60";
    readonly RadeonProV520: "radeon-pro-v520";
    readonly T4: "t4";
    readonly T4g: "t4g";
    readonly Vu9p: "vu9p";
    readonly V100: "v100";
};
export type Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem];
export declare const Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem: {
    readonly Gpu: "gpu";
    readonly Fpga: "fpga";
    readonly Inference: "inference";
};
export type Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem];
export declare const Ec2FleetInstanceRequirementsRequestBareMetal: {
    readonly Included: "included";
    readonly Required: "required";
    readonly Excluded: "excluded";
};
/**
 * Indicates whether bare metal instance types must be included, excluded, or required.
 *
 * - To include bare metal instance types, specify `included` .
 * - To require only bare metal instance types, specify `required` .
 * - To exclude bare metal instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type Ec2FleetInstanceRequirementsRequestBareMetal = (typeof Ec2FleetInstanceRequirementsRequestBareMetal)[keyof typeof Ec2FleetInstanceRequirementsRequestBareMetal];
export declare const Ec2FleetInstanceRequirementsRequestBurstablePerformance: {
    readonly Included: "included";
    readonly Required: "required";
    readonly Excluded: "excluded";
};
/**
 * Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
 *
 * - To include burstable performance instance types, specify `included` .
 * - To require only burstable performance instance types, specify `required` .
 * - To exclude burstable performance instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type Ec2FleetInstanceRequirementsRequestBurstablePerformance = (typeof Ec2FleetInstanceRequirementsRequestBurstablePerformance)[keyof typeof Ec2FleetInstanceRequirementsRequestBurstablePerformance];
export declare const Ec2FleetInstanceRequirementsRequestCpuManufacturersItem: {
    readonly Intel: "intel";
    readonly Amd: "amd";
    readonly AmazonWebServices: "amazon-web-services";
    readonly Apple: "apple";
};
export type Ec2FleetInstanceRequirementsRequestCpuManufacturersItem = (typeof Ec2FleetInstanceRequirementsRequestCpuManufacturersItem)[keyof typeof Ec2FleetInstanceRequirementsRequestCpuManufacturersItem];
export declare const Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem: {
    readonly Current: "current";
    readonly Previous: "previous";
};
export type Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem = (typeof Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem)[keyof typeof Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem];
export declare const Ec2FleetInstanceRequirementsRequestLocalStorage: {
    readonly Included: "included";
    readonly Required: "required";
    readonly Excluded: "excluded";
};
/**
 * Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
 *
 * - To include instance types with instance store volumes, specify `included` .
 * - To require only instance types with instance store volumes, specify `required` .
 * - To exclude instance types with instance store volumes, specify `excluded` .
 *
 * Default: `included`
 */
export type Ec2FleetInstanceRequirementsRequestLocalStorage = (typeof Ec2FleetInstanceRequirementsRequestLocalStorage)[keyof typeof Ec2FleetInstanceRequirementsRequestLocalStorage];
export declare const Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem: {
    readonly Hdd: "hdd";
    readonly Ssd: "ssd";
};
export type Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem = (typeof Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem];
export declare const Ec2FleetSpotOptionsRequestAllocationStrategy: {
    readonly LowestPrice: "lowest-price";
    readonly Diversified: "diversified";
    readonly CapacityOptimized: "capacityOptimized";
    readonly CapacityOptimizedPrioritized: "capacityOptimizedPrioritized";
    readonly PriceCapacityOptimized: "priceCapacityOptimized";
};
/**
 * Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
 *
 * If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
 *
 * If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
 *
 * If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
 *
 * *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
 */
export type Ec2FleetSpotOptionsRequestAllocationStrategy = (typeof Ec2FleetSpotOptionsRequestAllocationStrategy)[keyof typeof Ec2FleetSpotOptionsRequestAllocationStrategy];
export declare const Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior: {
    readonly Hibernate: "hibernate";
    readonly Stop: "stop";
    readonly Terminate: "terminate";
};
/**
 * The behavior when a Spot Instance is interrupted.
 *
 * Default: `terminate`
 */
export type Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior = (typeof Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior)[keyof typeof Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior];
export declare const Ec2FleetTagSpecificationResourceType: {
    readonly ClientVpnEndpoint: "client-vpn-endpoint";
    readonly CustomerGateway: "customer-gateway";
    readonly DedicatedHost: "dedicated-host";
    readonly DhcpOptions: "dhcp-options";
    readonly EgressOnlyInternetGateway: "egress-only-internet-gateway";
    readonly ElasticGpu: "elastic-gpu";
    readonly ElasticIp: "elastic-ip";
    readonly ExportImageTask: "export-image-task";
    readonly ExportInstanceTask: "export-instance-task";
    readonly Fleet: "fleet";
    readonly FpgaImage: "fpga-image";
    readonly HostReservation: "host-reservation";
    readonly Image: "image";
    readonly ImportImageTask: "import-image-task";
    readonly ImportSnapshotTask: "import-snapshot-task";
    readonly Instance: "instance";
    readonly InternetGateway: "internet-gateway";
    readonly KeyPair: "key-pair";
    readonly LaunchTemplate: "launch-template";
    readonly LocalGatewayRouteTableVpcAssociation: "local-gateway-route-table-vpc-association";
    readonly Natgateway: "natgateway";
    readonly NetworkAcl: "network-acl";
    readonly NetworkInsightsAnalysis: "network-insights-analysis";
    readonly NetworkInsightsPath: "network-insights-path";
    readonly NetworkInterface: "network-interface";
    readonly PlacementGroup: "placement-group";
    readonly ReservedInstances: "reserved-instances";
    readonly RouteTable: "route-table";
    readonly SecurityGroup: "security-group";
    readonly Snapshot: "snapshot";
    readonly SpotFleetRequest: "spot-fleet-request";
    readonly SpotInstancesRequest: "spot-instances-request";
    readonly Subnet: "subnet";
    readonly TrafficMirrorFilter: "traffic-mirror-filter";
    readonly TrafficMirrorSession: "traffic-mirror-session";
    readonly TrafficMirrorTarget: "traffic-mirror-target";
    readonly TransitGateway: "transit-gateway";
    readonly TransitGatewayAttachment: "transit-gateway-attachment";
    readonly TransitGatewayConnectPeer: "transit-gateway-connect-peer";
    readonly TransitGatewayMulticastDomain: "transit-gateway-multicast-domain";
    readonly TransitGatewayRouteTable: "transit-gateway-route-table";
    readonly Volume: "volume";
    readonly Vpc: "vpc";
    readonly VpcFlowLog: "vpc-flow-log";
    readonly VpcPeeringConnection: "vpc-peering-connection";
    readonly VpnConnection: "vpn-connection";
    readonly VpnGateway: "vpn-gateway";
};
/**
 * The type of resource to tag.
 */
export type Ec2FleetTagSpecificationResourceType = (typeof Ec2FleetTagSpecificationResourceType)[keyof typeof Ec2FleetTagSpecificationResourceType];
export declare const Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType: {
    readonly OnDemand: "on-demand";
    readonly Spot: "spot";
};
/**
 * The default target capacity type.
 */
export type Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType = (typeof Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType)[keyof typeof Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType];
export declare const Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType: {
    readonly Vcpu: "vcpu";
    readonly MemoryMib: "memory-mib";
    readonly Units: "units";
};
/**
 * The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.
 *
 * Default: `units` (the number of instances)
 */
export type Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType = (typeof Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType)[keyof typeof Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType];
export declare const Ec2FleetType: {
    readonly Maintain: "maintain";
    readonly Request: "request";
    readonly Instant: "instant";
};
/**
 * The fleet type. The default value is `maintain` .
 *
 * - `maintain` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
 * - `request` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
 * - `instant` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
 *
 * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
 */
export type Ec2FleetType = (typeof Ec2FleetType)[keyof typeof Ec2FleetType];
export declare const FlowLogDestinationOptionsPropertiesFileFormat: {
    readonly PlainText: "plain-text";
    readonly Parquet: "parquet";
};
/**
 * The format for the flow log. The default is `plain-text` .
 */
export type FlowLogDestinationOptionsPropertiesFileFormat = (typeof FlowLogDestinationOptionsPropertiesFileFormat)[keyof typeof FlowLogDestinationOptionsPropertiesFileFormat];
export declare const FlowLogLogDestinationType: {
    readonly CloudWatchLogs: "cloud-watch-logs";
    readonly S3: "s3";
    readonly KinesisDataFirehose: "kinesis-data-firehose";
};
/**
 * Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
 */
export type FlowLogLogDestinationType = (typeof FlowLogLogDestinationType)[keyof typeof FlowLogLogDestinationType];
export declare const FlowLogResourceType: {
    readonly NetworkInterface: "NetworkInterface";
    readonly Subnet: "Subnet";
    readonly Vpc: "VPC";
    readonly TransitGateway: "TransitGateway";
    readonly TransitGatewayAttachment: "TransitGatewayAttachment";
};
/**
 * The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ResourceId property, specify VPC for this property.
 */
export type FlowLogResourceType = (typeof FlowLogResourceType)[keyof typeof FlowLogResourceType];
export declare const FlowLogTrafficType: {
    readonly Accept: "ACCEPT";
    readonly All: "ALL";
    readonly Reject: "REJECT";
};
/**
 * The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
 */
export type FlowLogTrafficType = (typeof FlowLogTrafficType)[keyof typeof FlowLogTrafficType];
export declare const InstanceAffinity: {
    readonly Default: "default";
    readonly Host: "host";
};
/**
 * Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify host. If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify default.
 */
export type InstanceAffinity = (typeof InstanceAffinity)[keyof typeof InstanceAffinity];
export declare const InstancePrivateDnsNameOptionsHostnameType: {
    readonly IpName: "ip-name";
    readonly ResourceName: "resource-name";
};
/**
 * The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
 */
export type InstancePrivateDnsNameOptionsHostnameType = (typeof InstancePrivateDnsNameOptionsHostnameType)[keyof typeof InstancePrivateDnsNameOptionsHostnameType];
export declare const IpamPoolAwsService: {
    readonly Ec2: "ec2";
};
/**
 * Limits which service in Amazon Web Services that the pool can be used in.
 */
export type IpamPoolAwsService = (typeof IpamPoolAwsService)[keyof typeof IpamPoolAwsService];
export declare const IpamPoolIpamScopeType: {
    readonly Public: "public";
    readonly Private: "private";
};
/**
 * Determines whether this scope contains publicly routable space or space for a private network
 */
export type IpamPoolIpamScopeType = (typeof IpamPoolIpamScopeType)[keyof typeof IpamPoolIpamScopeType];
export declare const IpamPoolPublicIpSource: {
    readonly Byoip: "byoip";
    readonly Amazon: "amazon";
};
/**
 * The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Default is `byoip`.
 */
export type IpamPoolPublicIpSource = (typeof IpamPoolPublicIpSource)[keyof typeof IpamPoolPublicIpSource];
export declare const IpamPoolState: {
    readonly CreateInProgress: "create-in-progress";
    readonly CreateComplete: "create-complete";
    readonly ModifyInProgress: "modify-in-progress";
    readonly ModifyComplete: "modify-complete";
    readonly DeleteInProgress: "delete-in-progress";
    readonly DeleteComplete: "delete-complete";
};
/**
 * The state of this pool. This can be one of the following values: "create-in-progress", "create-complete", "modify-in-progress", "modify-complete", "delete-in-progress", or "delete-complete"
 */
export type IpamPoolState = (typeof IpamPoolState)[keyof typeof IpamPoolState];
export declare const IpamScopeType: {
    readonly Public: "public";
    readonly Private: "private";
};
/**
 * Determines whether this scope contains publicly routable space or space for a private network
 */
export type IpamScopeType = (typeof IpamScopeType)[keyof typeof IpamScopeType];
export declare const IpamTier: {
    readonly Free: "free";
    readonly Advanced: "advanced";
};
/**
 * The tier of the IPAM.
 */
export type IpamTier = (typeof IpamTier)[keyof typeof IpamTier];
export declare const KeyPairKeyFormat: {
    readonly Pem: "pem";
    readonly Ppk: "ppk";
};
/**
 * The format of the key pair.
 *  Default: ``pem``
 */
export type KeyPairKeyFormat = (typeof KeyPairKeyFormat)[keyof typeof KeyPairKeyFormat];
export declare const KeyPairKeyType: {
    readonly Rsa: "rsa";
    readonly Ed25519: "ed25519";
};
/**
 * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
 *  If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value.
 *  Default: ``rsa``
 */
export type KeyPairKeyType = (typeof KeyPairKeyType)[keyof typeof KeyPairKeyType];
export declare const LaunchTemplateCpuOptionsAmdSevSnp: {
    readonly Enabled: "enabled";
    readonly Disabled: "disabled";
};
/**
 * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
 */
export type LaunchTemplateCpuOptionsAmdSevSnp = (typeof LaunchTemplateCpuOptionsAmdSevSnp)[keyof typeof LaunchTemplateCpuOptionsAmdSevSnp];
export declare const NetworkInsightsAccessScopeAnalysisFindingsFound: {
    readonly True: "true";
    readonly False: "false";
    readonly Unknown: "unknown";
};
/**
 * Indicates whether there are findings (true | false | unknown).
 */
export type NetworkInsightsAccessScopeAnalysisFindingsFound = (typeof NetworkInsightsAccessScopeAnalysisFindingsFound)[keyof typeof NetworkInsightsAccessScopeAnalysisFindingsFound];
export declare const NetworkInsightsAccessScopeAnalysisStatus: {
    readonly Running: "running";
    readonly Failed: "failed";
    readonly Succeeded: "succeeded";
};
/**
 * The status of the analysis (running | succeeded | failed).
 */
export type NetworkInsightsAccessScopeAnalysisStatus = (typeof NetworkInsightsAccessScopeAnalysisStatus)[keyof typeof NetworkInsightsAccessScopeAnalysisStatus];
export declare const NetworkInsightsAccessScopeProtocol: {
    readonly Tcp: "tcp";
    readonly Udp: "udp";
};
export type NetworkInsightsAccessScopeProtocol = (typeof NetworkInsightsAccessScopeProtocol)[keyof typeof NetworkInsightsAccessScopeProtocol];
export declare const NetworkInsightsAnalysisStatus: {
    readonly Running: "running";
    readonly Failed: "failed";
    readonly Succeeded: "succeeded";
};
/**
 * The status of the network insights analysis.
 */
export type NetworkInsightsAnalysisStatus = (typeof NetworkInsightsAnalysisStatus)[keyof typeof NetworkInsightsAnalysisStatus];
export declare const NetworkInsightsPathProtocol: {
    readonly Tcp: "tcp";
    readonly Udp: "udp";
};
export type NetworkInsightsPathProtocol = (typeof NetworkInsightsPathProtocol)[keyof typeof NetworkInsightsPathProtocol];
export declare const PrefixListAddressFamily: {
    readonly IPv4: "IPv4";
    readonly IPv6: "IPv6";
};
/**
 * Ip Version of Prefix List.
 */
export type PrefixListAddressFamily = (typeof PrefixListAddressFamily)[keyof typeof PrefixListAddressFamily];
export declare const SecurityGroupVpcAssociationState: {
    readonly Associating: "associating";
    readonly Associated: "associated";
    readonly AssociationFailed: "association-failed";
    readonly Disassociating: "disassociating";
    readonly Disassociated: "disassociated";
    readonly DisassociationFailed: "disassociation-failed";
};
export type SecurityGroupVpcAssociationState = (typeof SecurityGroupVpcAssociationState)[keyof typeof SecurityGroupVpcAssociationState];
export declare const SnapshotBlockPublicAccessState: {
    readonly BlockAllSharing: "block-all-sharing";
    readonly BlockNewSharing: "block-new-sharing";
};
/**
 * The state of EBS Snapshot Block Public Access.
 */
export type SnapshotBlockPublicAccessState = (typeof SnapshotBlockPublicAccessState)[keyof typeof SnapshotBlockPublicAccessState];
export declare const SpotFleetEbsBlockDeviceVolumeType: {
    readonly Gp2: "gp2";
    readonly Gp3: "gp3";
    readonly Io1: "io1";
    readonly Io2: "io2";
    readonly Sc1: "sc1";
    readonly St1: "st1";
    readonly Standard: "standard";
};
/**
 * The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
 */
export type SpotFleetEbsBlockDeviceVolumeType = (typeof SpotFleetEbsBlockDeviceVolumeType)[keyof typeof SpotFleetEbsBlockDeviceVolumeType];
export declare const SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem: {
    readonly AmazonWebServices: "amazon-web-services";
    readonly Amd: "amd";
    readonly Habana: "habana";
    readonly Nvidia: "nvidia";
    readonly Xilinx: "xilinx";
};
export type SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem];
export declare const SpotFleetInstanceRequirementsRequestAcceleratorNamesItem: {
    readonly A10g: "a10g";
    readonly A100: "a100";
    readonly H100: "h100";
    readonly Inferentia: "inferentia";
    readonly K520: "k520";
    readonly K80: "k80";
    readonly M60: "m60";
    readonly RadeonProV520: "radeon-pro-v520";
    readonly T4: "t4";
    readonly T4g: "t4g";
    readonly Vu9p: "vu9p";
    readonly V100: "v100";
};
export type SpotFleetInstanceRequirementsRequestAcceleratorNamesItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorNamesItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorNamesItem];
export declare const SpotFleetInstanceRequirementsRequestAcceleratorTypesItem: {
    readonly Gpu: "gpu";
    readonly Fpga: "fpga";
    readonly Inference: "inference";
};
export type SpotFleetInstanceRequirementsRequestAcceleratorTypesItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorTypesItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorTypesItem];
export declare const SpotFleetInstanceRequirementsRequestBareMetal: {
    readonly Included: "included";
    readonly Required: "required";
    readonly Excluded: "excluded";
};
/**
 * Indicates whether bare metal instance types must be included, excluded, or required.
 *
 * - To include bare metal instance types, specify `included` .
 * - To require only bare metal instance types, specify `required` .
 * - To exclude bare metal instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type SpotFleetInstanceRequirementsRequestBareMetal = (typeof SpotFleetInstanceRequirementsRequestBareMetal)[keyof typeof SpotFleetInstanceRequirementsRequestBareMetal];
export declare const SpotFleetInstanceRequirementsRequestBurstablePerformance: {
    readonly Included: "included";
    readonly Required: "required";
    readonly Excluded: "excluded";
};
/**
 * Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
 *
 * - To include burstable performance instance types, specify `included` .
 * - To require only burstable performance instance types, specify `required` .
 * - To exclude burstable performance instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type SpotFleetInstanceRequirementsRequestBurstablePerformance = (typeof SpotFleetInstanceRequirementsRequestBurstablePerformance)[keyof typeof SpotFleetInstanceRequirementsRequestBurstablePerformance];
export declare const SpotFleetInstanceRequirementsRequestCpuManufacturersItem: {
    readonly Intel: "intel";
    readonly Amd: "amd";
    readonly AmazonWebServices: "amazon-web-services";
    readonly Apple: "apple";
};
export type SpotFleetInstanceRequirementsRequestCpuManufacturersItem = (typeof SpotFleetInstanceRequirementsRequestCpuManufacturersItem)[keyof typeof SpotFleetInstanceRequirementsRequestCpuManufacturersItem];
export declare const SpotFleetInstanceRequirementsRequestInstanceGenerationsItem: {
    readonly Current: "current";
    readonly Previous: "previous";
};
export type SpotFleetInstanceRequirementsRequestInstanceGenerationsItem = (typeof SpotFleetInstanceRequirementsRequestInstanceGenerationsItem)[keyof typeof SpotFleetInstanceRequirementsRequestInstanceGenerationsItem];
export declare const SpotFleetInstanceRequirementsRequestLocalStorage: {
    readonly Included: "included";
    readonly Required: "required";
    readonly Excluded: "excluded";
};
/**
 * Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
 *
 * - To include instance types with instance store volumes, specify `included` .
 * - To require only instance types with instance store volumes, specify `required` .
 * - To exclude instance types with instance store volumes, specify `excluded` .
 *
 * Default: `included`
 */
export type SpotFleetInstanceRequirementsRequestLocalStorage = (typeof SpotFleetInstanceRequirementsRequestLocalStorage)[keyof typeof SpotFleetInstanceRequirementsRequestLocalStorage];
export declare const SpotFleetInstanceRequirementsRequestLocalStorageTypesItem: {
    readonly Hdd: "hdd";
    readonly Ssd: "ssd";
};
export type SpotFleetInstanceRequirementsRequestLocalStorageTypesItem = (typeof SpotFleetInstanceRequirementsRequestLocalStorageTypesItem)[keyof typeof SpotFleetInstanceRequirementsRequestLocalStorageTypesItem];
export declare const SpotFleetRequestConfigDataAllocationStrategy: {
    readonly CapacityOptimized: "capacityOptimized";
    readonly CapacityOptimizedPrioritized: "capacityOptimizedPrioritized";
    readonly Diversified: "diversified";
    readonly LowestPrice: "lowestPrice";
    readonly PriceCapacityOptimized: "priceCapacityOptimized";
};
/**
 * The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
 *
 * - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
 * - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
 * - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
 * - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances.
 *
 * Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
 *
 * Default: `lowestPrice`
 */
export type SpotFleetRequestConfigDataAllocationStrategy = (typeof SpotFleetRequestConfigDataAllocationStrategy)[keyof typeof SpotFleetRequestConfigDataAllocationStrategy];
export declare const SpotFleetRequestConfigDataExcessCapacityTerminationPolicy: {
    readonly Default: "Default";
    readonly NoTermination: "NoTermination";
};
/**
 * Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
 *
 * Supported only for fleets of type `maintain` .
 */
export type SpotFleetRequestConfigDataExcessCapacityTerminationPolicy = (typeof SpotFleetRequestConfigDataExcessCapacityTerminationPolicy)[keyof typeof SpotFleetRequestConfigDataExcessCapacityTerminationPolicy];
export declare const SpotFleetRequestConfigDataInstanceInterruptionBehavior: {
    readonly Hibernate: "hibernate";
    readonly Stop: "stop";
    readonly Terminate: "terminate";
};
/**
 * The behavior when a Spot Instance is interrupted. The default is `terminate` .
 */
export type SpotFleetRequestConfigDataInstanceInterruptionBehavior = (typeof SpotFleetRequestConfigDataInstanceInterruptionBehavior)[keyof typeof SpotFleetRequestConfigDataInstanceInterruptionBehavior];
export declare const SpotFleetRequestConfigDataTargetCapacityUnitType: {
    readonly Vcpu: "vcpu";
    readonly MemoryMib: "memory-mib";
    readonly Units: "units";
};
/**
 * The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.
 *
 * Default: `units` (the number of instances)
 */
export type SpotFleetRequestConfigDataTargetCapacityUnitType = (typeof SpotFleetRequestConfigDataTargetCapacityUnitType)[keyof typeof SpotFleetRequestConfigDataTargetCapacityUnitType];
export declare const SpotFleetRequestConfigDataType: {
    readonly Maintain: "maintain";
    readonly Request: "request";
};
/**
 * The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
 */
export type SpotFleetRequestConfigDataType = (typeof SpotFleetRequestConfigDataType)[keyof typeof SpotFleetRequestConfigDataType];
export declare const SpotFleetSpotCapacityRebalanceReplacementStrategy: {
    readonly Launch: "launch";
    readonly LaunchBeforeTerminate: "launch-before-terminate";
};
/**
 * The replacement strategy to use. Only available for fleets of type `maintain` .
 *
 * `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
 *
 * `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
 */
export type SpotFleetSpotCapacityRebalanceReplacementStrategy = (typeof SpotFleetSpotCapacityRebalanceReplacementStrategy)[keyof typeof SpotFleetSpotCapacityRebalanceReplacementStrategy];
export declare const SpotFleetSpotPlacementTenancy: {
    readonly Dedicated: "dedicated";
    readonly Default: "default";
    readonly Host: "host";
};
/**
 * The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
 */
export type SpotFleetSpotPlacementTenancy = (typeof SpotFleetSpotPlacementTenancy)[keyof typeof SpotFleetSpotPlacementTenancy];
export declare const SpotFleetTagSpecificationResourceType: {
    readonly ClientVpnEndpoint: "client-vpn-endpoint";
    readonly CustomerGateway: "customer-gateway";
    readonly DedicatedHost: "dedicated-host";
    readonly DhcpOptions: "dhcp-options";
    readonly EgressOnlyInternetGateway: "egress-only-internet-gateway";
    readonly ElasticGpu: "elastic-gpu";
    readonly ElasticIp: "elastic-ip";
    readonly ExportImageTask: "export-image-task";
    readonly ExportInstanceTask: "export-instance-task";
    readonly Fleet: "fleet";
    readonly FpgaImage: "fpga-image";
    readonly HostReservation: "host-reservation";
    readonly Image: "image";
    readonly ImportImageTask: "import-image-task";
    readonly ImportSnapshotTask: "import-snapshot-task";
    readonly Instance: "instance";
    readonly InternetGateway: "internet-gateway";
    readonly KeyPair: "key-pair";
    readonly LaunchTemplate: "launch-template";
    readonly LocalGatewayRouteTableVpcAssociation: "local-gateway-route-table-vpc-association";
    readonly Natgateway: "natgateway";
    readonly NetworkAcl: "network-acl";
    readonly NetworkInsightsAnalysis: "network-insights-analysis";
    readonly NetworkInsightsPath: "network-insights-path";
    readonly NetworkInterface: "network-interface";
    readonly PlacementGroup: "placement-group";
    readonly ReservedInstances: "reserved-instances";
    readonly RouteTable: "route-table";
    readonly SecurityGroup: "security-group";
    readonly Snapshot: "snapshot";
    readonly SpotFleetRequest: "spot-fleet-request";
    readonly SpotInstancesRequest: "spot-instances-request";
    readonly Subnet: "subnet";
    readonly TrafficMirrorFilter: "traffic-mirror-filter";
    readonly TrafficMirrorSession: "traffic-mirror-session";
    readonly TrafficMirrorTarget: "traffic-mirror-target";
    readonly TransitGateway: "transit-gateway";
    readonly TransitGatewayAttachment: "transit-gateway-attachment";
    readonly TransitGatewayConnectPeer: "transit-gateway-connect-peer";
    readonly TransitGatewayMulticastDomain: "transit-gateway-multicast-domain";
    readonly TransitGatewayRouteTable: "transit-gateway-route-table";
    readonly Volume: "volume";
    readonly Vpc: "vpc";
    readonly VpcFlowLog: "vpc-flow-log";
    readonly VpcPeeringConnection: "vpc-peering-connection";
    readonly VpnConnection: "vpn-connection";
    readonly VpnGateway: "vpn-gateway";
};
/**
 * The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
 */
export type SpotFleetTagSpecificationResourceType = (typeof SpotFleetTagSpecificationResourceType)[keyof typeof SpotFleetTagSpecificationResourceType];
export declare const VpcBlockPublicAccessExclusionInternetGatewayExclusionMode: {
    readonly AllowBidirectional: "allow-bidirectional";
    readonly AllowEgress: "allow-egress";
};
/**
 * The desired Block Public Access Exclusion Mode for a specific VPC/Subnet.
 */
export type VpcBlockPublicAccessExclusionInternetGatewayExclusionMode = (typeof VpcBlockPublicAccessExclusionInternetGatewayExclusionMode)[keyof typeof VpcBlockPublicAccessExclusionInternetGatewayExclusionMode];
export declare const VpcBlockPublicAccessOptionsInternetGatewayBlockMode: {
    readonly BlockBidirectional: "block-bidirectional";
    readonly BlockIngress: "block-ingress";
};
/**
 * The desired Block Public Access mode for Internet Gateways in your account. We do not allow to create in a off mode as this is the default value
 */
export type VpcBlockPublicAccessOptionsInternetGatewayBlockMode = (typeof VpcBlockPublicAccessOptionsInternetGatewayBlockMode)[keyof typeof VpcBlockPublicAccessOptionsInternetGatewayBlockMode];
export declare const VpcEndpointDnsOptionsSpecificationDnsRecordIpType: {
    readonly Ipv4: "ipv4";
    readonly Ipv6: "ipv6";
    readonly Dualstack: "dualstack";
    readonly ServiceDefined: "service-defined";
    readonly NotSpecified: "not-specified";
};
export type VpcEndpointDnsOptionsSpecificationDnsRecordIpType = (typeof VpcEndpointDnsOptionsSpecificationDnsRecordIpType)[keyof typeof VpcEndpointDnsOptionsSpecificationDnsRecordIpType];
export declare const VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint: {
    readonly OnlyInboundResolver: "OnlyInboundResolver";
    readonly AllResolvers: "AllResolvers";
    readonly NotSpecified: "NotSpecified";
};
export type VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint = (typeof VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint)[keyof typeof VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint];
export declare const VpcEndpointIpAddressType: {
    readonly Ipv4: "ipv4";
    readonly Ipv6: "ipv6";
    readonly Dualstack: "dualstack";
    readonly NotSpecified: "not-specified";
};
export type VpcEndpointIpAddressType = (typeof VpcEndpointIpAddressType)[keyof typeof VpcEndpointIpAddressType];
export declare const VpcEndpointType: {
    readonly Interface: "Interface";
    readonly Gateway: "Gateway";
    readonly GatewayLoadBalancer: "GatewayLoadBalancer";
    readonly ServiceNetwork: "ServiceNetwork";
    readonly Resource: "Resource";
};
/**
 * The type of endpoint.
 *  Default: Gateway
 */
export type VpcEndpointType = (typeof VpcEndpointType)[keyof typeof VpcEndpointType];
export declare const VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat: {
    readonly Json: "json";
    readonly Text: "text";
};
/**
 * Set log format. Default format is ``json``.
 *  Valid values: ``json`` | ``text``
 */
export type VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat = (typeof VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat)[keyof typeof VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat];
export declare const VpnConnectionIkeVersionsRequestListValueValue: {
    readonly Ikev1: "ikev1";
    readonly Ikev2: "ikev2";
};
/**
 * The IKE version.
 */
export type VpnConnectionIkeVersionsRequestListValueValue = (typeof VpnConnectionIkeVersionsRequestListValueValue)[keyof typeof VpnConnectionIkeVersionsRequestListValueValue];
export declare const VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue: {
    readonly Aes128: "AES128";
    readonly Aes256: "AES256";
    readonly Aes128Gcm16: "AES128-GCM-16";
    readonly Aes256Gcm16: "AES256-GCM-16";
};
/**
 * The value for the encryption algorithm.
 */
export type VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue];
export declare const VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue: {
    readonly Sha1: "SHA1";
    readonly Sha2256: "SHA2-256";
    readonly Sha2384: "SHA2-384";
    readonly Sha2512: "SHA2-512";
};
/**
 * The value for the integrity algorithm.
 */
export type VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue];
export declare const VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue: {
    readonly Aes128: "AES128";
    readonly Aes256: "AES256";
    readonly Aes128Gcm16: "AES128-GCM-16";
    readonly Aes256Gcm16: "AES256-GCM-16";
};
/**
 * The encryption algorithm.
 */
export type VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue];
export declare const VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue: {
    readonly Sha1: "SHA1";
    readonly Sha2256: "SHA2-256";
    readonly Sha2384: "SHA2-384";
    readonly Sha2512: "SHA2-512";
};
/**
 * The integrity algorithm.
 */
export type VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue];
export declare const VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction: {
    readonly Clear: "clear";
    readonly None: "none";
    readonly Restart: "restart";
};
/**
 * The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
 *  Valid Values: ``clear`` | ``none`` | ``restart``
 *  Default: ``clear``
 */
export type VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction = (typeof VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction)[keyof typeof VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction];
export declare const VpnConnectionVpnTunnelOptionsSpecificationStartupAction: {
    readonly Add: "add";
    readonly Start: "start";
};
/**
 * The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
 *  Valid Values: ``add`` | ``start``
 *  Default: ``add``
 */
export type VpnConnectionVpnTunnelOptionsSpecificationStartupAction = (typeof VpnConnectionVpnTunnelOptionsSpecificationStartupAction)[keyof typeof VpnConnectionVpnTunnelOptionsSpecificationStartupAction];
