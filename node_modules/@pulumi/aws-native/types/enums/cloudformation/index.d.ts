export declare const GuardHookAction: {
    readonly Create: "CREATE";
    readonly Update: "UPDATE";
    readonly Delete: "DELETE";
};
/**
 * Target actions are the type of operation hooks will be executed at.
 */
export type GuardHookAction = (typeof GuardHookAction)[keyof typeof GuardHookAction];
export declare const GuardHookFailureMode: {
    readonly Fail: "FAIL";
    readonly Warn: "WARN";
};
/**
 * Attribute to specify CloudFormation behavior on hook failure.
 */
export type GuardHookFailureMode = (typeof GuardHookFailureMode)[keyof typeof GuardHookFailureMode];
export declare const GuardHookHookStatus: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * Attribute to specify which stacks this hook applies to or should get invoked for
 */
export type GuardHookHookStatus = (typeof GuardHookHookStatus)[keyof typeof GuardHookHookStatus];
export declare const GuardHookInvocationPoint: {
    readonly PreProvision: "PRE_PROVISION";
};
/**
 * Invocation points are the point in provisioning workflow where hooks will be executed.
 */
export type GuardHookInvocationPoint = (typeof GuardHookInvocationPoint)[keyof typeof GuardHookInvocationPoint];
export declare const GuardHookStackFiltersPropertiesFilteringCriteria: {
    readonly All: "ALL";
    readonly Any: "ANY";
};
/**
 * Attribute to specify the filtering behavior. ANY will make the Hook pass if one filter matches. ALL will make the Hook pass if all filters match
 */
export type GuardHookStackFiltersPropertiesFilteringCriteria = (typeof GuardHookStackFiltersPropertiesFilteringCriteria)[keyof typeof GuardHookStackFiltersPropertiesFilteringCriteria];
export declare const GuardHookTargetOperation: {
    readonly Resource: "RESOURCE";
    readonly Stack: "STACK";
    readonly ChangeSet: "CHANGE_SET";
    readonly CloudControl: "CLOUD_CONTROL";
};
/**
 * Which operations should this Hook run against? Resource changes, stacks or change sets.
 */
export type GuardHookTargetOperation = (typeof GuardHookTargetOperation)[keyof typeof GuardHookTargetOperation];
export declare const HookTypeConfigConfigurationAlias: {
    readonly Default: "default";
};
/**
 * An alias by which to refer to this extension configuration data.
 */
export type HookTypeConfigConfigurationAlias = (typeof HookTypeConfigConfigurationAlias)[keyof typeof HookTypeConfigConfigurationAlias];
export declare const HookVersionVisibility: {
    readonly Public: "PUBLIC";
    readonly Private: "PRIVATE";
};
/**
 * The scope at which the type is visible and usable in CloudFormation operations.
 *
 * Valid values include:
 *
 * PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
 *
 * PUBLIC: The type is publically visible and usable within any Amazon account.
 */
export type HookVersionVisibility = (typeof HookVersionVisibility)[keyof typeof HookVersionVisibility];
export declare const LambdaHookAction: {
    readonly Create: "CREATE";
    readonly Update: "UPDATE";
    readonly Delete: "DELETE";
};
/**
 * Target actions are the type of operation hooks will be executed at.
 */
export type LambdaHookAction = (typeof LambdaHookAction)[keyof typeof LambdaHookAction];
export declare const LambdaHookFailureMode: {
    readonly Fail: "FAIL";
    readonly Warn: "WARN";
};
/**
 * Attribute to specify CloudFormation behavior on hook failure.
 */
export type LambdaHookFailureMode = (typeof LambdaHookFailureMode)[keyof typeof LambdaHookFailureMode];
export declare const LambdaHookHookStatus: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * Attribute to specify which stacks this hook applies to or should get invoked for
 */
export type LambdaHookHookStatus = (typeof LambdaHookHookStatus)[keyof typeof LambdaHookHookStatus];
export declare const LambdaHookInvocationPoint: {
    readonly PreProvision: "PRE_PROVISION";
};
/**
 * Invocation points are the point in provisioning workflow where hooks will be executed.
 */
export type LambdaHookInvocationPoint = (typeof LambdaHookInvocationPoint)[keyof typeof LambdaHookInvocationPoint];
export declare const LambdaHookStackFiltersPropertiesFilteringCriteria: {
    readonly All: "ALL";
    readonly Any: "ANY";
};
/**
 * Attribute to specify the filtering behavior. ANY will make the Hook pass if one filter matches. ALL will make the Hook pass if all filters match
 */
export type LambdaHookStackFiltersPropertiesFilteringCriteria = (typeof LambdaHookStackFiltersPropertiesFilteringCriteria)[keyof typeof LambdaHookStackFiltersPropertiesFilteringCriteria];
export declare const LambdaHookTargetOperation: {
    readonly Resource: "RESOURCE";
    readonly Stack: "STACK";
    readonly ChangeSet: "CHANGE_SET";
    readonly CloudControl: "CLOUD_CONTROL";
};
/**
 * Which operations should this Hook run against? Resource changes, stacks or change sets.
 */
export type LambdaHookTargetOperation = (typeof LambdaHookTargetOperation)[keyof typeof LambdaHookTargetOperation];
export declare const ModuleVersionVisibility: {
    readonly Private: "PRIVATE";
};
/**
 * The scope at which the type is visible and usable in CloudFormation operations.
 *
 * The only allowed value at present is:
 *
 * PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
 */
export type ModuleVersionVisibility = (typeof ModuleVersionVisibility)[keyof typeof ModuleVersionVisibility];
export declare const PublicTypeVersionType: {
    readonly Resource: "RESOURCE";
    readonly Module: "MODULE";
    readonly Hook: "HOOK";
};
/**
 * The kind of extension
 */
export type PublicTypeVersionType = (typeof PublicTypeVersionType)[keyof typeof PublicTypeVersionType];
export declare const PublisherIdentityProvider: {
    readonly AwsMarketplace: "AWS_Marketplace";
    readonly GitHub: "GitHub";
    readonly Bitbucket: "Bitbucket";
};
/**
 * The type of account used as the identity provider when registering this publisher with CloudFormation.
 */
export type PublisherIdentityProvider = (typeof PublisherIdentityProvider)[keyof typeof PublisherIdentityProvider];
export declare const PublisherStatus: {
    readonly Verified: "VERIFIED";
    readonly Unverified: "UNVERIFIED";
};
/**
 * Whether the publisher is verified.
 */
export type PublisherStatus = (typeof PublisherStatus)[keyof typeof PublisherStatus];
export declare const ResourceVersionProvisioningType: {
    readonly NonProvisionable: "NON_PROVISIONABLE";
    readonly Immutable: "IMMUTABLE";
    readonly FullyMutable: "FULLY_MUTABLE";
};
/**
 * The provisioning behavior of the type. AWS CloudFormation determines the provisioning type during registration, based on the types of handlers in the schema handler package submitted.
 */
export type ResourceVersionProvisioningType = (typeof ResourceVersionProvisioningType)[keyof typeof ResourceVersionProvisioningType];
export declare const ResourceVersionVisibility: {
    readonly Public: "PUBLIC";
    readonly Private: "PRIVATE";
};
/**
 * The scope at which the type is visible and usable in CloudFormation operations.
 *
 * Valid values include:
 *
 * PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
 *
 * PUBLIC: The type is publically visible and usable within any Amazon account.
 */
export type ResourceVersionVisibility = (typeof ResourceVersionVisibility)[keyof typeof ResourceVersionVisibility];
export declare const StackCapabilitiesItem: {
    readonly CapabilityIam: "CAPABILITY_IAM";
    readonly CapabilityNamedIam: "CAPABILITY_NAMED_IAM";
    readonly CapabilityAutoExpand: "CAPABILITY_AUTO_EXPAND";
};
export type StackCapabilitiesItem = (typeof StackCapabilitiesItem)[keyof typeof StackCapabilitiesItem];
export declare const StackSetCallAs: {
    readonly Self: "SELF";
    readonly DelegatedAdmin: "DELEGATED_ADMIN";
};
/**
 * Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
 */
export type StackSetCallAs = (typeof StackSetCallAs)[keyof typeof StackSetCallAs];
export declare const StackSetCapability: {
    readonly CapabilityIam: "CAPABILITY_IAM";
    readonly CapabilityNamedIam: "CAPABILITY_NAMED_IAM";
    readonly CapabilityAutoExpand: "CAPABILITY_AUTO_EXPAND";
};
export type StackSetCapability = (typeof StackSetCapability)[keyof typeof StackSetCapability];
export declare const StackSetConcurrencyMode: {
    readonly StrictFailureTolerance: "STRICT_FAILURE_TOLERANCE";
    readonly SoftFailureTolerance: "SOFT_FAILURE_TOLERANCE";
};
/**
 * Specifies how the concurrency level behaves during the operation execution.
 */
export type StackSetConcurrencyMode = (typeof StackSetConcurrencyMode)[keyof typeof StackSetConcurrencyMode];
export declare const StackSetDeploymentTargetsAccountFilterType: {
    readonly None: "NONE";
    readonly Union: "UNION";
    readonly Intersection: "INTERSECTION";
    readonly Difference: "DIFFERENCE";
};
/**
 * The filter type you want to apply on organizational units and accounts.
 */
export type StackSetDeploymentTargetsAccountFilterType = (typeof StackSetDeploymentTargetsAccountFilterType)[keyof typeof StackSetDeploymentTargetsAccountFilterType];
export declare const StackSetPermissionModel: {
    readonly ServiceManaged: "SERVICE_MANAGED";
    readonly SelfManaged: "SELF_MANAGED";
};
/**
 * Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
 */
export type StackSetPermissionModel = (typeof StackSetPermissionModel)[keyof typeof StackSetPermissionModel];
export declare const StackSetRegionConcurrencyType: {
    readonly Sequential: "SEQUENTIAL";
    readonly Parallel: "PARALLEL";
};
/**
 * The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time
 */
export type StackSetRegionConcurrencyType = (typeof StackSetRegionConcurrencyType)[keyof typeof StackSetRegionConcurrencyType];
export declare const StackStatus: {
    readonly CreateInProgress: "CREATE_IN_PROGRESS";
    readonly CreateFailed: "CREATE_FAILED";
    readonly CreateComplete: "CREATE_COMPLETE";
    readonly RollbackInProgress: "ROLLBACK_IN_PROGRESS";
    readonly RollbackFailed: "ROLLBACK_FAILED";
    readonly RollbackComplete: "ROLLBACK_COMPLETE";
    readonly DeleteInProgress: "DELETE_IN_PROGRESS";
    readonly DeleteFailed: "DELETE_FAILED";
    readonly DeleteComplete: "DELETE_COMPLETE";
    readonly UpdateInProgress: "UPDATE_IN_PROGRESS";
    readonly UpdateCompleteCleanupInProgress: "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS";
    readonly UpdateComplete: "UPDATE_COMPLETE";
    readonly UpdateFailed: "UPDATE_FAILED";
    readonly UpdateRollbackInProgress: "UPDATE_ROLLBACK_IN_PROGRESS";
    readonly UpdateRollbackFailed: "UPDATE_ROLLBACK_FAILED";
    readonly UpdateRollbackCompleteCleanupInProgress: "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS";
    readonly UpdateRollbackComplete: "UPDATE_ROLLBACK_COMPLETE";
    readonly ReviewInProgress: "REVIEW_IN_PROGRESS";
    readonly ImportInProgress: "IMPORT_IN_PROGRESS";
    readonly ImportComplete: "IMPORT_COMPLETE";
    readonly ImportRollbackInProgress: "IMPORT_ROLLBACK_IN_PROGRESS";
    readonly ImportRollbackFailed: "IMPORT_ROLLBACK_FAILED";
    readonly ImportRollbackComplete: "IMPORT_ROLLBACK_COMPLETE";
};
/**
 * Current status of the stack.
 */
export type StackStatus = (typeof StackStatus)[keyof typeof StackStatus];
export declare const TypeActivationType: {
    readonly Resource: "RESOURCE";
    readonly Module: "MODULE";
    readonly Hook: "HOOK";
};
/**
 * The kind of extension
 */
export type TypeActivationType = (typeof TypeActivationType)[keyof typeof TypeActivationType];
export declare const TypeActivationVersionBump: {
    readonly Major: "MAJOR";
    readonly Minor: "MINOR";
};
/**
 * Manually updates a previously-enabled type to a new major or minor version, if available. You can also use this parameter to update the value of AutoUpdateEnabled
 */
export type TypeActivationVersionBump = (typeof TypeActivationVersionBump)[keyof typeof TypeActivationVersionBump];
