export declare const AliasRoutingStrategyType: {
    readonly Simple: "SIMPLE";
    readonly Terminal: "TERMINAL";
};
/**
 * Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
 */
export type AliasRoutingStrategyType = (typeof AliasRoutingStrategyType)[keyof typeof AliasRoutingStrategyType];
export declare const BuildOperatingSystem: {
    readonly AmazonLinux: "AMAZON_LINUX";
    readonly AmazonLinux2: "AMAZON_LINUX_2";
    readonly AmazonLinux2023: "AMAZON_LINUX_2023";
    readonly Windows2012: "WINDOWS_2012";
    readonly Windows2016: "WINDOWS_2016";
};
/**
 * The operating system that the game server binaries are built to run on. This value determines the type of fleet resources that you can use for this build. If your game build contains multiple executables, they all must run on the same operating system. If an operating system is not specified when creating a build, Amazon GameLift uses the default value (WINDOWS_2012). This value cannot be changed later.
 */
export type BuildOperatingSystem = (typeof BuildOperatingSystem)[keyof typeof BuildOperatingSystem];
export declare const ContainerFleetBillingType: {
    readonly OnDemand: "ON_DEMAND";
    readonly Spot: "SPOT";
};
/**
 * Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.
 */
export type ContainerFleetBillingType = (typeof ContainerFleetBillingType)[keyof typeof ContainerFleetBillingType];
export declare const ContainerFleetDeploymentConfigurationImpairmentStrategy: {
    readonly Maintain: "MAINTAIN";
    readonly Rollback: "ROLLBACK";
};
/**
 * The strategy to apply in case of impairment; defaults to MAINTAIN.
 */
export type ContainerFleetDeploymentConfigurationImpairmentStrategy = (typeof ContainerFleetDeploymentConfigurationImpairmentStrategy)[keyof typeof ContainerFleetDeploymentConfigurationImpairmentStrategy];
export declare const ContainerFleetDeploymentConfigurationProtectionStrategy: {
    readonly WithProtection: "WITH_PROTECTION";
    readonly IgnoreProtection: "IGNORE_PROTECTION";
};
/**
 * The protection strategy for deployment on the container fleet; defaults to WITH_PROTECTION.
 */
export type ContainerFleetDeploymentConfigurationProtectionStrategy = (typeof ContainerFleetDeploymentConfigurationProtectionStrategy)[keyof typeof ContainerFleetDeploymentConfigurationProtectionStrategy];
export declare const ContainerFleetIpPermissionProtocol: {
    readonly Tcp: "TCP";
    readonly Udp: "UDP";
};
/**
 * The network communication protocol used by the fleet.
 */
export type ContainerFleetIpPermissionProtocol = (typeof ContainerFleetIpPermissionProtocol)[keyof typeof ContainerFleetIpPermissionProtocol];
export declare const ContainerFleetLogDestination: {
    readonly None: "NONE";
    readonly Cloudwatch: "CLOUDWATCH";
    readonly S3: "S3";
};
/**
 * Configures the service that provides logs.
 */
export type ContainerFleetLogDestination = (typeof ContainerFleetLogDestination)[keyof typeof ContainerFleetLogDestination];
export declare const ContainerFleetNewGameSessionProtectionPolicy: {
    readonly FullProtection: "FullProtection";
    readonly NoProtection: "NoProtection";
};
/**
 * A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.
 */
export type ContainerFleetNewGameSessionProtectionPolicy = (typeof ContainerFleetNewGameSessionProtectionPolicy)[keyof typeof ContainerFleetNewGameSessionProtectionPolicy];
export declare const ContainerFleetScalingPolicyComparisonOperator: {
    readonly GreaterThanOrEqualToThreshold: "GreaterThanOrEqualToThreshold";
    readonly GreaterThanThreshold: "GreaterThanThreshold";
    readonly LessThanThreshold: "LessThanThreshold";
    readonly LessThanOrEqualToThreshold: "LessThanOrEqualToThreshold";
};
/**
 * Comparison operator to use when measuring a metric against the threshold value.
 */
export type ContainerFleetScalingPolicyComparisonOperator = (typeof ContainerFleetScalingPolicyComparisonOperator)[keyof typeof ContainerFleetScalingPolicyComparisonOperator];
export declare const ContainerFleetScalingPolicyMetricName: {
    readonly ActivatingGameSessions: "ActivatingGameSessions";
    readonly ActiveGameSessions: "ActiveGameSessions";
    readonly ActiveInstances: "ActiveInstances";
    readonly AvailableGameSessions: "AvailableGameSessions";
    readonly AvailablePlayerSessions: "AvailablePlayerSessions";
    readonly CurrentPlayerSessions: "CurrentPlayerSessions";
    readonly IdleInstances: "IdleInstances";
    readonly PercentAvailableGameSessions: "PercentAvailableGameSessions";
    readonly PercentIdleInstances: "PercentIdleInstances";
    readonly QueueDepth: "QueueDepth";
    readonly WaitTime: "WaitTime";
    readonly ConcurrentActivatableGameSessions: "ConcurrentActivatableGameSessions";
};
/**
 * Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
 */
export type ContainerFleetScalingPolicyMetricName = (typeof ContainerFleetScalingPolicyMetricName)[keyof typeof ContainerFleetScalingPolicyMetricName];
export declare const ContainerFleetScalingPolicyPolicyType: {
    readonly RuleBased: "RuleBased";
    readonly TargetBased: "TargetBased";
};
/**
 * The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
 */
export type ContainerFleetScalingPolicyPolicyType = (typeof ContainerFleetScalingPolicyPolicyType)[keyof typeof ContainerFleetScalingPolicyPolicyType];
export declare const ContainerFleetScalingPolicyScalingAdjustmentType: {
    readonly ChangeInCapacity: "ChangeInCapacity";
    readonly ExactCapacity: "ExactCapacity";
    readonly PercentChangeInCapacity: "PercentChangeInCapacity";
};
/**
 * The type of adjustment to make to a fleet's instance count.
 */
export type ContainerFleetScalingPolicyScalingAdjustmentType = (typeof ContainerFleetScalingPolicyScalingAdjustmentType)[keyof typeof ContainerFleetScalingPolicyScalingAdjustmentType];
export declare const ContainerFleetStatus: {
    readonly Pending: "PENDING";
    readonly Creating: "CREATING";
    readonly Created: "CREATED";
    readonly Activating: "ACTIVATING";
    readonly Active: "ACTIVE";
    readonly Updating: "UPDATING";
    readonly Deleting: "DELETING";
};
/**
 * The current status of the container fleet.
 */
export type ContainerFleetStatus = (typeof ContainerFleetStatus)[keyof typeof ContainerFleetStatus];
export declare const ContainerFleetStoppedActionsItem: {
    readonly AutoScaling: "AUTO_SCALING";
};
export type ContainerFleetStoppedActionsItem = (typeof ContainerFleetStoppedActionsItem)[keyof typeof ContainerFleetStoppedActionsItem];
export declare const ContainerGroupDefinitionContainerDependencyCondition: {
    readonly Start: "START";
    readonly Complete: "COMPLETE";
    readonly Success: "SUCCESS";
    readonly Healthy: "HEALTHY";
};
/**
 * The type of dependency.
 */
export type ContainerGroupDefinitionContainerDependencyCondition = (typeof ContainerGroupDefinitionContainerDependencyCondition)[keyof typeof ContainerGroupDefinitionContainerDependencyCondition];
export declare const ContainerGroupDefinitionContainerGroupType: {
    readonly GameServer: "GAME_SERVER";
    readonly PerInstance: "PER_INSTANCE";
};
/**
 * The scope of the container group
 */
export type ContainerGroupDefinitionContainerGroupType = (typeof ContainerGroupDefinitionContainerGroupType)[keyof typeof ContainerGroupDefinitionContainerGroupType];
export declare const ContainerGroupDefinitionContainerMountPointAccessLevel: {
    readonly ReadOnly: "READ_ONLY";
    readonly ReadAndWrite: "READ_AND_WRITE";
};
/**
 * The access permissions for the mounted path.
 */
export type ContainerGroupDefinitionContainerMountPointAccessLevel = (typeof ContainerGroupDefinitionContainerMountPointAccessLevel)[keyof typeof ContainerGroupDefinitionContainerMountPointAccessLevel];
export declare const ContainerGroupDefinitionContainerPortRangeProtocol: {
    readonly Tcp: "TCP";
    readonly Udp: "UDP";
};
/**
 * Defines the protocol of these ports.
 */
export type ContainerGroupDefinitionContainerPortRangeProtocol = (typeof ContainerGroupDefinitionContainerPortRangeProtocol)[keyof typeof ContainerGroupDefinitionContainerPortRangeProtocol];
export declare const ContainerGroupDefinitionOperatingSystem: {
    readonly AmazonLinux2023: "AMAZON_LINUX_2023";
};
/**
 * The operating system of the container group
 */
export type ContainerGroupDefinitionOperatingSystem = (typeof ContainerGroupDefinitionOperatingSystem)[keyof typeof ContainerGroupDefinitionOperatingSystem];
export declare const ContainerGroupDefinitionStatus: {
    readonly Ready: "READY";
    readonly Copying: "COPYING";
    readonly Failed: "FAILED";
};
/**
 * A string indicating ContainerGroupDefinition status.
 */
export type ContainerGroupDefinitionStatus = (typeof ContainerGroupDefinitionStatus)[keyof typeof ContainerGroupDefinitionStatus];
export declare const FleetApplyCapacity: {
    readonly OnUpdate: "ON_UPDATE";
    readonly OnCreateAndUpdate: "ON_CREATE_AND_UPDATE";
};
/**
 * Determines whether to apply fleet or location capacities on fleet creation.
 */
export type FleetApplyCapacity = (typeof FleetApplyCapacity)[keyof typeof FleetApplyCapacity];
export declare const FleetCertificateConfigurationCertificateType: {
    readonly Disabled: "DISABLED";
    readonly Generated: "GENERATED";
};
/**
 * Indicates whether a TLS/SSL certificate is generated for a fleet.
 *
 * Valid values include:
 *
 * - *GENERATED* - Generate a TLS/SSL certificate for this fleet.
 * - *DISABLED* - (default) Do not generate a TLS/SSL certificate for this fleet.
 */
export type FleetCertificateConfigurationCertificateType = (typeof FleetCertificateConfigurationCertificateType)[keyof typeof FleetCertificateConfigurationCertificateType];
export declare const FleetComputeType: {
    readonly Ec2: "EC2";
    readonly Anywhere: "ANYWHERE";
};
/**
 * ComputeType to differentiate EC2 hardware managed by GameLift and Anywhere hardware managed by the customer.
 */
export type FleetComputeType = (typeof FleetComputeType)[keyof typeof FleetComputeType];
export declare const FleetInstanceRoleCredentialsProvider: {
    readonly SharedCredentialFile: "SHARED_CREDENTIAL_FILE";
};
/**
 * Credentials provider implementation that loads credentials from the Amazon EC2 Instance Metadata Service.
 */
export type FleetInstanceRoleCredentialsProvider = (typeof FleetInstanceRoleCredentialsProvider)[keyof typeof FleetInstanceRoleCredentialsProvider];
export declare const FleetIpPermissionProtocol: {
    readonly Tcp: "TCP";
    readonly Udp: "UDP";
};
/**
 * The network communication protocol used by the fleet.
 */
export type FleetIpPermissionProtocol = (typeof FleetIpPermissionProtocol)[keyof typeof FleetIpPermissionProtocol];
export declare const FleetNewGameSessionProtectionPolicy: {
    readonly FullProtection: "FullProtection";
    readonly NoProtection: "NoProtection";
};
/**
 * A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.
 */
export type FleetNewGameSessionProtectionPolicy = (typeof FleetNewGameSessionProtectionPolicy)[keyof typeof FleetNewGameSessionProtectionPolicy];
export declare const FleetScalingPolicyComparisonOperator: {
    readonly GreaterThanOrEqualToThreshold: "GreaterThanOrEqualToThreshold";
    readonly GreaterThanThreshold: "GreaterThanThreshold";
    readonly LessThanThreshold: "LessThanThreshold";
    readonly LessThanOrEqualToThreshold: "LessThanOrEqualToThreshold";
};
/**
 * Comparison operator to use when measuring a metric against the threshold value.
 */
export type FleetScalingPolicyComparisonOperator = (typeof FleetScalingPolicyComparisonOperator)[keyof typeof FleetScalingPolicyComparisonOperator];
export declare const FleetScalingPolicyMetricName: {
    readonly ActivatingGameSessions: "ActivatingGameSessions";
    readonly ActiveGameSessions: "ActiveGameSessions";
    readonly ActiveInstances: "ActiveInstances";
    readonly AvailableGameSessions: "AvailableGameSessions";
    readonly AvailablePlayerSessions: "AvailablePlayerSessions";
    readonly CurrentPlayerSessions: "CurrentPlayerSessions";
    readonly IdleInstances: "IdleInstances";
    readonly PercentAvailableGameSessions: "PercentAvailableGameSessions";
    readonly PercentIdleInstances: "PercentIdleInstances";
    readonly QueueDepth: "QueueDepth";
    readonly WaitTime: "WaitTime";
    readonly ConcurrentActivatableGameSessions: "ConcurrentActivatableGameSessions";
};
/**
 * Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
 */
export type FleetScalingPolicyMetricName = (typeof FleetScalingPolicyMetricName)[keyof typeof FleetScalingPolicyMetricName];
export declare const FleetScalingPolicyPolicyType: {
    readonly RuleBased: "RuleBased";
    readonly TargetBased: "TargetBased";
};
/**
 * The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
 */
export type FleetScalingPolicyPolicyType = (typeof FleetScalingPolicyPolicyType)[keyof typeof FleetScalingPolicyPolicyType];
export declare const FleetScalingPolicyScalingAdjustmentType: {
    readonly ChangeInCapacity: "ChangeInCapacity";
    readonly ExactCapacity: "ExactCapacity";
    readonly PercentChangeInCapacity: "PercentChangeInCapacity";
};
/**
 * The type of adjustment to make to a fleet's instance count.
 */
export type FleetScalingPolicyScalingAdjustmentType = (typeof FleetScalingPolicyScalingAdjustmentType)[keyof typeof FleetScalingPolicyScalingAdjustmentType];
export declare const FleetScalingPolicyStatus: {
    readonly Active: "ACTIVE";
    readonly UpdateRequested: "UPDATE_REQUESTED";
    readonly Updating: "UPDATING";
    readonly DeleteRequested: "DELETE_REQUESTED";
    readonly Deleting: "DELETING";
    readonly Deleted: "DELETED";
    readonly Error: "ERROR";
};
/**
 * Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
 */
export type FleetScalingPolicyStatus = (typeof FleetScalingPolicyStatus)[keyof typeof FleetScalingPolicyStatus];
export declare const FleetScalingPolicyUpdateStatus: {
    readonly PendingUpdate: "PENDING_UPDATE";
};
/**
 * The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
 */
export type FleetScalingPolicyUpdateStatus = (typeof FleetScalingPolicyUpdateStatus)[keyof typeof FleetScalingPolicyUpdateStatus];
export declare const FleetType: {
    readonly OnDemand: "ON_DEMAND";
    readonly Spot: "SPOT";
};
/**
 * Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.
 */
export type FleetType = (typeof FleetType)[keyof typeof FleetType];
export declare const GameServerGroupBalancingStrategy: {
    readonly SpotOnly: "SPOT_ONLY";
    readonly SpotPreferred: "SPOT_PREFERRED";
    readonly OnDemandOnly: "ON_DEMAND_ONLY";
};
/**
 * The fallback balancing method to use for the game server group when Spot Instances in a Region become unavailable or are not viable for game hosting.
 */
export type GameServerGroupBalancingStrategy = (typeof GameServerGroupBalancingStrategy)[keyof typeof GameServerGroupBalancingStrategy];
export declare const GameServerGroupDeleteOption: {
    readonly SafeDelete: "SAFE_DELETE";
    readonly ForceDelete: "FORCE_DELETE";
    readonly Retain: "RETAIN";
};
/**
 * The type of delete to perform.
 */
export type GameServerGroupDeleteOption = (typeof GameServerGroupDeleteOption)[keyof typeof GameServerGroupDeleteOption];
export declare const GameServerGroupGameServerProtectionPolicy: {
    readonly NoProtection: "NO_PROTECTION";
    readonly FullProtection: "FULL_PROTECTION";
};
/**
 * A flag that indicates whether instances in the game server group are protected from early termination.
 */
export type GameServerGroupGameServerProtectionPolicy = (typeof GameServerGroupGameServerProtectionPolicy)[keyof typeof GameServerGroupGameServerProtectionPolicy];
export declare const GameSessionQueuePriorityOrderItem: {
    readonly Latency: "LATENCY";
    readonly Cost: "COST";
    readonly Destination: "DESTINATION";
    readonly Location: "LOCATION";
};
export type GameSessionQueuePriorityOrderItem = (typeof GameSessionQueuePriorityOrderItem)[keyof typeof GameSessionQueuePriorityOrderItem];
export declare const MatchmakingConfigurationBackfillMode: {
    readonly Automatic: "AUTOMATIC";
    readonly Manual: "MANUAL";
};
/**
 * The method used to backfill game sessions created with this matchmaking configuration.
 */
export type MatchmakingConfigurationBackfillMode = (typeof MatchmakingConfigurationBackfillMode)[keyof typeof MatchmakingConfigurationBackfillMode];
export declare const MatchmakingConfigurationFlexMatchMode: {
    readonly Standalone: "STANDALONE";
    readonly WithQueue: "WITH_QUEUE";
};
/**
 * Indicates whether this matchmaking configuration is being used with Amazon GameLift hosting or as a standalone matchmaking solution.
 */
export type MatchmakingConfigurationFlexMatchMode = (typeof MatchmakingConfigurationFlexMatchMode)[keyof typeof MatchmakingConfigurationFlexMatchMode];
