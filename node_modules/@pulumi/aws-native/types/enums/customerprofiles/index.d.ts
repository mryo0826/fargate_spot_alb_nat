export declare const CalculatedAttributeDefinitionRangeUnit: {
    readonly Days: "DAYS";
};
/**
 * The unit of time.
 */
export type CalculatedAttributeDefinitionRangeUnit = (typeof CalculatedAttributeDefinitionRangeUnit)[keyof typeof CalculatedAttributeDefinitionRangeUnit];
export declare const CalculatedAttributeDefinitionStatistic: {
    readonly FirstOccurrence: "FIRST_OCCURRENCE";
    readonly LastOccurrence: "LAST_OCCURRENCE";
    readonly Count: "COUNT";
    readonly Sum: "SUM";
    readonly Minimum: "MINIMUM";
    readonly Maximum: "MAXIMUM";
    readonly Average: "AVERAGE";
    readonly MaxOccurrence: "MAX_OCCURRENCE";
};
/**
 * The aggregation operation to perform for the calculated attribute.
 */
export type CalculatedAttributeDefinitionStatistic = (typeof CalculatedAttributeDefinitionStatistic)[keyof typeof CalculatedAttributeDefinitionStatistic];
export declare const CalculatedAttributeDefinitionThresholdOperator: {
    readonly EqualTo: "EQUAL_TO";
    readonly GreaterThan: "GREATER_THAN";
    readonly LessThan: "LESS_THAN";
    readonly NotEqualTo: "NOT_EQUAL_TO";
};
/**
 * The operator of the threshold.
 */
export type CalculatedAttributeDefinitionThresholdOperator = (typeof CalculatedAttributeDefinitionThresholdOperator)[keyof typeof CalculatedAttributeDefinitionThresholdOperator];
export declare const DomainAttributeTypesSelectorAttributeMatchingModel: {
    readonly OneToOne: "ONE_TO_ONE";
    readonly ManyToMany: "MANY_TO_MANY";
};
/**
 * Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
 */
export type DomainAttributeTypesSelectorAttributeMatchingModel = (typeof DomainAttributeTypesSelectorAttributeMatchingModel)[keyof typeof DomainAttributeTypesSelectorAttributeMatchingModel];
export declare const DomainConflictResolutionConflictResolvingModel: {
    readonly Recency: "RECENCY";
    readonly Source: "SOURCE";
};
/**
 * How the auto-merging process should resolve conflicts between different profiles.
 */
export type DomainConflictResolutionConflictResolvingModel = (typeof DomainConflictResolutionConflictResolvingModel)[keyof typeof DomainConflictResolutionConflictResolvingModel];
export declare const DomainJobScheduleDayOfTheWeek: {
    readonly Sunday: "SUNDAY";
    readonly Monday: "MONDAY";
    readonly Tuesday: "TUESDAY";
    readonly Wednesday: "WEDNESDAY";
    readonly Thursday: "THURSDAY";
    readonly Friday: "FRIDAY";
    readonly Saturday: "SATURDAY";
};
/**
 * The day when the Identity Resolution Job should run every week.
 */
export type DomainJobScheduleDayOfTheWeek = (typeof DomainJobScheduleDayOfTheWeek)[keyof typeof DomainJobScheduleDayOfTheWeek];
export declare const DomainRuleBasedMatchingStatus: {
    readonly Pending: "PENDING";
    readonly InProgress: "IN_PROGRESS";
    readonly Active: "ACTIVE";
};
/**
 * The status of rule-based matching rule.
 */
export type DomainRuleBasedMatchingStatus = (typeof DomainRuleBasedMatchingStatus)[keyof typeof DomainRuleBasedMatchingStatus];
export declare const EventStreamState: {
    readonly Running: "RUNNING";
    readonly Stopped: "STOPPED";
};
/**
 * The operational state of destination stream for export.
 */
export type EventStreamState = (typeof EventStreamState)[keyof typeof EventStreamState];
export declare const EventStreamStatus: {
    readonly Healthy: "HEALTHY";
    readonly Unhealthy: "UNHEALTHY";
};
/**
 * The status of enabling the Kinesis stream as a destination for export.
 */
export type EventStreamStatus = (typeof EventStreamStatus)[keyof typeof EventStreamStatus];
export declare const IntegrationConnectorType: {
    readonly Salesforce: "Salesforce";
    readonly Marketo: "Marketo";
    readonly ServiceNow: "ServiceNow";
    readonly Zendesk: "Zendesk";
    readonly S3: "S3";
};
export type IntegrationConnectorType = (typeof IntegrationConnectorType)[keyof typeof IntegrationConnectorType];
export declare const IntegrationMarketoConnectorOperator: {
    readonly Projection: "PROJECTION";
    readonly LessThan: "LESS_THAN";
    readonly GreaterThan: "GREATER_THAN";
    readonly Between: "BETWEEN";
    readonly Addition: "ADDITION";
    readonly Multiplication: "MULTIPLICATION";
    readonly Division: "DIVISION";
    readonly Subtraction: "SUBTRACTION";
    readonly MaskAll: "MASK_ALL";
    readonly MaskFirstN: "MASK_FIRST_N";
    readonly MaskLastN: "MASK_LAST_N";
    readonly ValidateNonNull: "VALIDATE_NON_NULL";
    readonly ValidateNonZero: "VALIDATE_NON_ZERO";
    readonly ValidateNonNegative: "VALIDATE_NON_NEGATIVE";
    readonly ValidateNumeric: "VALIDATE_NUMERIC";
    readonly NoOp: "NO_OP";
};
export type IntegrationMarketoConnectorOperator = (typeof IntegrationMarketoConnectorOperator)[keyof typeof IntegrationMarketoConnectorOperator];
export declare const IntegrationOperatorPropertiesKeys: {
    readonly Value: "VALUE";
    readonly Values: "VALUES";
    readonly DataType: "DATA_TYPE";
    readonly UpperBound: "UPPER_BOUND";
    readonly LowerBound: "LOWER_BOUND";
    readonly SourceDataType: "SOURCE_DATA_TYPE";
    readonly DestinationDataType: "DESTINATION_DATA_TYPE";
    readonly ValidationAction: "VALIDATION_ACTION";
    readonly MaskValue: "MASK_VALUE";
    readonly MaskLength: "MASK_LENGTH";
    readonly TruncateLength: "TRUNCATE_LENGTH";
    readonly MathOperationFieldsOrder: "MATH_OPERATION_FIELDS_ORDER";
    readonly ConcatFormat: "CONCAT_FORMAT";
    readonly SubfieldCategoryMap: "SUBFIELD_CATEGORY_MAP";
};
export type IntegrationOperatorPropertiesKeys = (typeof IntegrationOperatorPropertiesKeys)[keyof typeof IntegrationOperatorPropertiesKeys];
export declare const IntegrationS3ConnectorOperator: {
    readonly Projection: "PROJECTION";
    readonly LessThan: "LESS_THAN";
    readonly GreaterThan: "GREATER_THAN";
    readonly Between: "BETWEEN";
    readonly LessThanOrEqualTo: "LESS_THAN_OR_EQUAL_TO";
    readonly GreaterThanOrEqualTo: "GREATER_THAN_OR_EQUAL_TO";
    readonly EqualTo: "EQUAL_TO";
    readonly NotEqualTo: "NOT_EQUAL_TO";
    readonly Addition: "ADDITION";
    readonly Multiplication: "MULTIPLICATION";
    readonly Division: "DIVISION";
    readonly Subtraction: "SUBTRACTION";
    readonly MaskAll: "MASK_ALL";
    readonly MaskFirstN: "MASK_FIRST_N";
    readonly MaskLastN: "MASK_LAST_N";
    readonly ValidateNonNull: "VALIDATE_NON_NULL";
    readonly ValidateNonZero: "VALIDATE_NON_ZERO";
    readonly ValidateNonNegative: "VALIDATE_NON_NEGATIVE";
    readonly ValidateNumeric: "VALIDATE_NUMERIC";
    readonly NoOp: "NO_OP";
};
export type IntegrationS3ConnectorOperator = (typeof IntegrationS3ConnectorOperator)[keyof typeof IntegrationS3ConnectorOperator];
export declare const IntegrationSalesforceConnectorOperator: {
    readonly Projection: "PROJECTION";
    readonly LessThan: "LESS_THAN";
    readonly GreaterThan: "GREATER_THAN";
    readonly Contains: "CONTAINS";
    readonly Between: "BETWEEN";
    readonly LessThanOrEqualTo: "LESS_THAN_OR_EQUAL_TO";
    readonly GreaterThanOrEqualTo: "GREATER_THAN_OR_EQUAL_TO";
    readonly EqualTo: "EQUAL_TO";
    readonly NotEqualTo: "NOT_EQUAL_TO";
    readonly Addition: "ADDITION";
    readonly Multiplication: "MULTIPLICATION";
    readonly Division: "DIVISION";
    readonly Subtraction: "SUBTRACTION";
    readonly MaskAll: "MASK_ALL";
    readonly MaskFirstN: "MASK_FIRST_N";
    readonly MaskLastN: "MASK_LAST_N";
    readonly ValidateNonNull: "VALIDATE_NON_NULL";
    readonly ValidateNonZero: "VALIDATE_NON_ZERO";
    readonly ValidateNonNegative: "VALIDATE_NON_NEGATIVE";
    readonly ValidateNumeric: "VALIDATE_NUMERIC";
    readonly NoOp: "NO_OP";
};
export type IntegrationSalesforceConnectorOperator = (typeof IntegrationSalesforceConnectorOperator)[keyof typeof IntegrationSalesforceConnectorOperator];
export declare const IntegrationScheduledTriggerPropertiesDataPullMode: {
    readonly Incremental: "Incremental";
    readonly Complete: "Complete";
};
/**
 * Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
 */
export type IntegrationScheduledTriggerPropertiesDataPullMode = (typeof IntegrationScheduledTriggerPropertiesDataPullMode)[keyof typeof IntegrationScheduledTriggerPropertiesDataPullMode];
export declare const IntegrationServiceNowConnectorOperator: {
    readonly Projection: "PROJECTION";
    readonly LessThan: "LESS_THAN";
    readonly GreaterThan: "GREATER_THAN";
    readonly Contains: "CONTAINS";
    readonly Between: "BETWEEN";
    readonly LessThanOrEqualTo: "LESS_THAN_OR_EQUAL_TO";
    readonly GreaterThanOrEqualTo: "GREATER_THAN_OR_EQUAL_TO";
    readonly EqualTo: "EQUAL_TO";
    readonly NotEqualTo: "NOT_EQUAL_TO";
    readonly Addition: "ADDITION";
    readonly Multiplication: "MULTIPLICATION";
    readonly Division: "DIVISION";
    readonly Subtraction: "SUBTRACTION";
    readonly MaskAll: "MASK_ALL";
    readonly MaskFirstN: "MASK_FIRST_N";
    readonly MaskLastN: "MASK_LAST_N";
    readonly ValidateNonNull: "VALIDATE_NON_NULL";
    readonly ValidateNonZero: "VALIDATE_NON_ZERO";
    readonly ValidateNonNegative: "VALIDATE_NON_NEGATIVE";
    readonly ValidateNumeric: "VALIDATE_NUMERIC";
    readonly NoOp: "NO_OP";
};
export type IntegrationServiceNowConnectorOperator = (typeof IntegrationServiceNowConnectorOperator)[keyof typeof IntegrationServiceNowConnectorOperator];
export declare const IntegrationTaskType: {
    readonly Arithmetic: "Arithmetic";
    readonly Filter: "Filter";
    readonly Map: "Map";
    readonly Mask: "Mask";
    readonly Merge: "Merge";
    readonly Truncate: "Truncate";
    readonly Validate: "Validate";
};
export type IntegrationTaskType = (typeof IntegrationTaskType)[keyof typeof IntegrationTaskType];
export declare const IntegrationTriggerType: {
    readonly Scheduled: "Scheduled";
    readonly Event: "Event";
    readonly OnDemand: "OnDemand";
};
export type IntegrationTriggerType = (typeof IntegrationTriggerType)[keyof typeof IntegrationTriggerType];
export declare const IntegrationZendeskConnectorOperator: {
    readonly Projection: "PROJECTION";
    readonly GreaterThan: "GREATER_THAN";
    readonly Addition: "ADDITION";
    readonly Multiplication: "MULTIPLICATION";
    readonly Division: "DIVISION";
    readonly Subtraction: "SUBTRACTION";
    readonly MaskAll: "MASK_ALL";
    readonly MaskFirstN: "MASK_FIRST_N";
    readonly MaskLastN: "MASK_LAST_N";
    readonly ValidateNonNull: "VALIDATE_NON_NULL";
    readonly ValidateNonZero: "VALIDATE_NON_ZERO";
    readonly ValidateNonNegative: "VALIDATE_NON_NEGATIVE";
    readonly ValidateNumeric: "VALIDATE_NUMERIC";
    readonly NoOp: "NO_OP";
};
export type IntegrationZendeskConnectorOperator = (typeof IntegrationZendeskConnectorOperator)[keyof typeof IntegrationZendeskConnectorOperator];
export declare const ObjectTypeFieldContentType: {
    readonly String: "STRING";
    readonly Number: "NUMBER";
    readonly PhoneNumber: "PHONE_NUMBER";
    readonly EmailAddress: "EMAIL_ADDRESS";
    readonly Name: "NAME";
};
/**
 * The content type of the field. Used for determining equality when searching.
 */
export type ObjectTypeFieldContentType = (typeof ObjectTypeFieldContentType)[keyof typeof ObjectTypeFieldContentType];
export declare const ObjectTypeKeyStandardIdentifiersItem: {
    readonly Profile: "PROFILE";
    readonly Unique: "UNIQUE";
    readonly Secondary: "SECONDARY";
    readonly LookupOnly: "LOOKUP_ONLY";
    readonly NewOnly: "NEW_ONLY";
    readonly Asset: "ASSET";
    readonly Case: "CASE";
    readonly Order: "ORDER";
};
export type ObjectTypeKeyStandardIdentifiersItem = (typeof ObjectTypeKeyStandardIdentifiersItem)[keyof typeof ObjectTypeKeyStandardIdentifiersItem];
export declare const SegmentDefinitionAttributeDimensionType: {
    readonly Inclusive: "INCLUSIVE";
    readonly Exclusive: "EXCLUSIVE";
    readonly Contains: "CONTAINS";
    readonly BeginsWith: "BEGINS_WITH";
    readonly EndsWith: "ENDS_WITH";
    readonly Before: "BEFORE";
    readonly After: "AFTER";
    readonly Between: "BETWEEN";
    readonly NotBetween: "NOT_BETWEEN";
    readonly On: "ON";
    readonly GreaterThan: "GREATER_THAN";
    readonly LessThan: "LESS_THAN";
    readonly GreaterThanOrEqual: "GREATER_THAN_OR_EQUAL";
    readonly LessThanOrEqual: "LESS_THAN_OR_EQUAL";
    readonly Equal: "EQUAL";
};
/**
 * The type of segment dimension to use.
 */
export type SegmentDefinitionAttributeDimensionType = (typeof SegmentDefinitionAttributeDimensionType)[keyof typeof SegmentDefinitionAttributeDimensionType];
export declare const SegmentDefinitionDateDimensionType: {
    readonly Before: "BEFORE";
    readonly After: "AFTER";
    readonly Between: "BETWEEN";
    readonly NotBetween: "NOT_BETWEEN";
    readonly On: "ON";
};
/**
 * The type of segment dimension to use for a date dimension.
 */
export type SegmentDefinitionDateDimensionType = (typeof SegmentDefinitionDateDimensionType)[keyof typeof SegmentDefinitionDateDimensionType];
export declare const SegmentDefinitionIncludeOptions: {
    readonly All: "ALL";
    readonly Any: "ANY";
    readonly None: "NONE";
};
/**
 * Specifies the operator on how to handle multiple groups within the same segment.
 */
export type SegmentDefinitionIncludeOptions = (typeof SegmentDefinitionIncludeOptions)[keyof typeof SegmentDefinitionIncludeOptions];
export declare const SegmentDefinitionRangeOverrideUnit: {
    readonly Days: "DAYS";
};
/**
 * The unit to be applied to the range.
 */
export type SegmentDefinitionRangeOverrideUnit = (typeof SegmentDefinitionRangeOverrideUnit)[keyof typeof SegmentDefinitionRangeOverrideUnit];
export declare const SegmentDefinitionStringDimensionType: {
    readonly Inclusive: "INCLUSIVE";
    readonly Exclusive: "EXCLUSIVE";
    readonly Contains: "CONTAINS";
    readonly BeginsWith: "BEGINS_WITH";
    readonly EndsWith: "ENDS_WITH";
};
/**
 * The type of segment dimension to use for a string dimension.
 */
export type SegmentDefinitionStringDimensionType = (typeof SegmentDefinitionStringDimensionType)[keyof typeof SegmentDefinitionStringDimensionType];
