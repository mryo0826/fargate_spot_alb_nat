export declare const AppResourceSpecInstanceType: {
    readonly System: "system";
    readonly MlT3Micro: "ml.t3.micro";
    readonly MlT3Small: "ml.t3.small";
    readonly MlT3Medium: "ml.t3.medium";
    readonly MlT3Large: "ml.t3.large";
    readonly MlT3Xlarge: "ml.t3.xlarge";
    readonly MlT32xlarge: "ml.t3.2xlarge";
    readonly MlM5Large: "ml.m5.large";
    readonly MlM5Xlarge: "ml.m5.xlarge";
    readonly MlM52xlarge: "ml.m5.2xlarge";
    readonly MlM54xlarge: "ml.m5.4xlarge";
    readonly MlM58xlarge: "ml.m5.8xlarge";
    readonly MlM512xlarge: "ml.m5.12xlarge";
    readonly MlM516xlarge: "ml.m5.16xlarge";
    readonly MlM524xlarge: "ml.m5.24xlarge";
    readonly MlC5Large: "ml.c5.large";
    readonly MlC5Xlarge: "ml.c5.xlarge";
    readonly MlC52xlarge: "ml.c5.2xlarge";
    readonly MlC54xlarge: "ml.c5.4xlarge";
    readonly MlC59xlarge: "ml.c5.9xlarge";
    readonly MlC512xlarge: "ml.c5.12xlarge";
    readonly MlC518xlarge: "ml.c5.18xlarge";
    readonly MlC524xlarge: "ml.c5.24xlarge";
    readonly MlP32xlarge: "ml.p3.2xlarge";
    readonly MlP38xlarge: "ml.p3.8xlarge";
    readonly MlP316xlarge: "ml.p3.16xlarge";
    readonly MlG4dnXlarge: "ml.g4dn.xlarge";
    readonly MlG4dn2xlarge: "ml.g4dn.2xlarge";
    readonly MlG4dn4xlarge: "ml.g4dn.4xlarge";
    readonly MlG4dn8xlarge: "ml.g4dn.8xlarge";
    readonly MlG4dn12xlarge: "ml.g4dn.12xlarge";
    readonly MlG4dn16xlarge: "ml.g4dn.16xlarge";
    readonly MlR5Large: "ml.r5.large";
    readonly MlR5Xlarge: "ml.r5.xlarge";
    readonly MlR52xlarge: "ml.r5.2xlarge";
    readonly MlR54xlarge: "ml.r5.4xlarge";
    readonly MlR58xlarge: "ml.r5.8xlarge";
    readonly MlR512xlarge: "ml.r5.12xlarge";
    readonly MlR516xlarge: "ml.r5.16xlarge";
    readonly MlR524xlarge: "ml.r5.24xlarge";
    readonly MlP3dn24xlarge: "ml.p3dn.24xlarge";
    readonly MlM5dLarge: "ml.m5d.large";
    readonly MlM5dXlarge: "ml.m5d.xlarge";
    readonly MlM5d2xlarge: "ml.m5d.2xlarge";
    readonly MlM5d4xlarge: "ml.m5d.4xlarge";
    readonly MlM5d8xlarge: "ml.m5d.8xlarge";
    readonly MlM5d12xlarge: "ml.m5d.12xlarge";
    readonly MlM5d16xlarge: "ml.m5d.16xlarge";
    readonly MlM5d24xlarge: "ml.m5d.24xlarge";
    readonly MlG5Xlarge: "ml.g5.xlarge";
    readonly MlG52xlarge: "ml.g5.2xlarge";
    readonly MlG54xlarge: "ml.g5.4xlarge";
    readonly MlG58xlarge: "ml.g5.8xlarge";
    readonly MlG512xlarge: "ml.g5.12xlarge";
    readonly MlG516xlarge: "ml.g5.16xlarge";
    readonly MlG524xlarge: "ml.g5.24xlarge";
    readonly MlG548xlarge: "ml.g5.48xlarge";
    readonly MlP4d24xlarge: "ml.p4d.24xlarge";
    readonly MlP4de24xlarge: "ml.p4de.24xlarge";
    readonly MlGeospatialInteractive: "ml.geospatial.interactive";
    readonly MlTrn12xlarge: "ml.trn1.2xlarge";
    readonly MlTrn132xlarge: "ml.trn1.32xlarge";
    readonly MlTrn1n32xlarge: "ml.trn1n.32xlarge";
};
/**
 * The instance type that the image version runs on.
 */
export type AppResourceSpecInstanceType = (typeof AppResourceSpecInstanceType)[keyof typeof AppResourceSpecInstanceType];
export declare const AppType: {
    readonly JupyterServer: "JupyterServer";
    readonly KernelGateway: "KernelGateway";
    readonly RStudioServerPro: "RStudioServerPro";
    readonly RSessionGateway: "RSessionGateway";
    readonly Canvas: "Canvas";
};
/**
 * The type of app.
 */
export type AppType = (typeof AppType)[keyof typeof AppType];
export declare const ClusterDeepHealthCheckType: {
    readonly InstanceStress: "InstanceStress";
    readonly InstanceConnectivity: "InstanceConnectivity";
};
/**
 * The type of deep health check(s) to be performed on the instances in the SageMaker HyperPod cluster instance group.
 */
export type ClusterDeepHealthCheckType = (typeof ClusterDeepHealthCheckType)[keyof typeof ClusterDeepHealthCheckType];
export declare const ClusterNodeRecovery: {
    readonly Automatic: "Automatic";
    readonly None: "None";
};
/**
 * If node auto-recovery is set to true, faulty nodes will be replaced or rebooted when a failure is detected. If set to false, nodes will be labelled when a fault is detected.
 */
export type ClusterNodeRecovery = (typeof ClusterNodeRecovery)[keyof typeof ClusterNodeRecovery];
export declare const ClusterStatus: {
    readonly Creating: "Creating";
    readonly Deleting: "Deleting";
    readonly Failed: "Failed";
    readonly InService: "InService";
    readonly RollingBack: "RollingBack";
    readonly SystemUpdating: "SystemUpdating";
    readonly Updating: "Updating";
};
/**
 * The status of the HyperPod Cluster.
 */
export type ClusterStatus = (typeof ClusterStatus)[keyof typeof ClusterStatus];
export declare const DataQualityJobDefinitionBatchTransformInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type DataQualityJobDefinitionBatchTransformInputS3DataDistributionType = (typeof DataQualityJobDefinitionBatchTransformInputS3DataDistributionType)[keyof typeof DataQualityJobDefinitionBatchTransformInputS3DataDistributionType];
export declare const DataQualityJobDefinitionBatchTransformInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type DataQualityJobDefinitionBatchTransformInputS3InputMode = (typeof DataQualityJobDefinitionBatchTransformInputS3InputMode)[keyof typeof DataQualityJobDefinitionBatchTransformInputS3InputMode];
export declare const DataQualityJobDefinitionEndpointInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type DataQualityJobDefinitionEndpointInputS3DataDistributionType = (typeof DataQualityJobDefinitionEndpointInputS3DataDistributionType)[keyof typeof DataQualityJobDefinitionEndpointInputS3DataDistributionType];
export declare const DataQualityJobDefinitionEndpointInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type DataQualityJobDefinitionEndpointInputS3InputMode = (typeof DataQualityJobDefinitionEndpointInputS3InputMode)[keyof typeof DataQualityJobDefinitionEndpointInputS3InputMode];
export declare const DataQualityJobDefinitionS3OutputS3UploadMode: {
    readonly Continuous: "Continuous";
    readonly EndOfJob: "EndOfJob";
};
/**
 * Whether to upload the results of the monitoring job continuously or after the job completes.
 */
export type DataQualityJobDefinitionS3OutputS3UploadMode = (typeof DataQualityJobDefinitionS3OutputS3UploadMode)[keyof typeof DataQualityJobDefinitionS3OutputS3UploadMode];
export declare const DomainAppNetworkAccessType: {
    readonly PublicInternetOnly: "PublicInternetOnly";
    readonly VpcOnly: "VpcOnly";
};
/**
 * Specifies the VPC used for non-EFS traffic. The default value is PublicInternetOnly.
 */
export type DomainAppNetworkAccessType = (typeof DomainAppNetworkAccessType)[keyof typeof DomainAppNetworkAccessType];
export declare const DomainAppSecurityGroupManagement: {
    readonly Service: "Service";
    readonly Customer: "Customer";
};
/**
 * The entity that creates and manages the required security groups for inter-app communication in VPCOnly mode. Required when CreateDomain.AppNetworkAccessType is VPCOnly and DomainSettings.RStudioServerProDomainSettings.DomainExecutionRoleArn is provided.
 */
export type DomainAppSecurityGroupManagement = (typeof DomainAppSecurityGroupManagement)[keyof typeof DomainAppSecurityGroupManagement];
export declare const DomainAppType: {
    readonly JupyterServer: "JupyterServer";
    readonly TensorBoard: "TensorBoard";
    readonly RStudioServerPro: "RStudioServerPro";
    readonly JupyterLab: "JupyterLab";
    readonly CodeEditor: "CodeEditor";
    readonly DetailedProfiler: "DetailedProfiler";
    readonly Canvas: "Canvas";
};
export type DomainAppType = (typeof DomainAppType)[keyof typeof DomainAppType];
export declare const DomainAuthMode: {
    readonly Sso: "SSO";
    readonly Iam: "IAM";
};
/**
 * The mode of authentication that members use to access the domain.
 */
export type DomainAuthMode = (typeof DomainAuthMode)[keyof typeof DomainAuthMode];
export declare const DomainDockerSettingsEnableDockerAccess: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * The flag to enable/disable docker-proxy server
 */
export type DomainDockerSettingsEnableDockerAccess = (typeof DomainDockerSettingsEnableDockerAccess)[keyof typeof DomainDockerSettingsEnableDockerAccess];
export declare const DomainLifecycleManagement: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * A flag to enable/disable AppLifecycleManagement settings
 */
export type DomainLifecycleManagement = (typeof DomainLifecycleManagement)[keyof typeof DomainLifecycleManagement];
export declare const DomainMlTools: {
    readonly DataWrangler: "DataWrangler";
    readonly FeatureStore: "FeatureStore";
    readonly EmrClusters: "EmrClusters";
    readonly AutoMl: "AutoMl";
    readonly Experiments: "Experiments";
    readonly Training: "Training";
    readonly ModelEvaluation: "ModelEvaluation";
    readonly Pipelines: "Pipelines";
    readonly Models: "Models";
    readonly JumpStart: "JumpStart";
    readonly InferenceRecommender: "InferenceRecommender";
    readonly Endpoints: "Endpoints";
    readonly Projects: "Projects";
    readonly InferenceOptimization: "InferenceOptimization";
    readonly HyperPodClusters: "HyperPodClusters";
    readonly Comet: "Comet";
    readonly DeepchecksLlmEvaluation: "DeepchecksLLMEvaluation";
    readonly Fiddler: "Fiddler";
    readonly LakeraGuard: "LakeraGuard";
};
export type DomainMlTools = (typeof DomainMlTools)[keyof typeof DomainMlTools];
export declare const DomainRStudioServerProAppSettingsAccessStatus: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * Indicates whether the current user has access to the RStudioServerPro app.
 */
export type DomainRStudioServerProAppSettingsAccessStatus = (typeof DomainRStudioServerProAppSettingsAccessStatus)[keyof typeof DomainRStudioServerProAppSettingsAccessStatus];
export declare const DomainRStudioServerProAppSettingsUserGroup: {
    readonly RStudioAdmin: "R_STUDIO_ADMIN";
    readonly RStudioUser: "R_STUDIO_USER";
};
/**
 * The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
 */
export type DomainRStudioServerProAppSettingsUserGroup = (typeof DomainRStudioServerProAppSettingsUserGroup)[keyof typeof DomainRStudioServerProAppSettingsUserGroup];
export declare const DomainResourceSpecInstanceType: {
    readonly System: "system";
    readonly MlT3Micro: "ml.t3.micro";
    readonly MlT3Small: "ml.t3.small";
    readonly MlT3Medium: "ml.t3.medium";
    readonly MlT3Large: "ml.t3.large";
    readonly MlT3Xlarge: "ml.t3.xlarge";
    readonly MlT32xlarge: "ml.t3.2xlarge";
    readonly MlM5Large: "ml.m5.large";
    readonly MlM5Xlarge: "ml.m5.xlarge";
    readonly MlM52xlarge: "ml.m5.2xlarge";
    readonly MlM54xlarge: "ml.m5.4xlarge";
    readonly MlM58xlarge: "ml.m5.8xlarge";
    readonly MlM512xlarge: "ml.m5.12xlarge";
    readonly MlM516xlarge: "ml.m5.16xlarge";
    readonly MlM524xlarge: "ml.m5.24xlarge";
    readonly MlC5Large: "ml.c5.large";
    readonly MlC5Xlarge: "ml.c5.xlarge";
    readonly MlC52xlarge: "ml.c5.2xlarge";
    readonly MlC54xlarge: "ml.c5.4xlarge";
    readonly MlC59xlarge: "ml.c5.9xlarge";
    readonly MlC512xlarge: "ml.c5.12xlarge";
    readonly MlC518xlarge: "ml.c5.18xlarge";
    readonly MlC524xlarge: "ml.c5.24xlarge";
    readonly MlP32xlarge: "ml.p3.2xlarge";
    readonly MlP38xlarge: "ml.p3.8xlarge";
    readonly MlP316xlarge: "ml.p3.16xlarge";
    readonly MlG4dnXlarge: "ml.g4dn.xlarge";
    readonly MlG4dn2xlarge: "ml.g4dn.2xlarge";
    readonly MlG4dn4xlarge: "ml.g4dn.4xlarge";
    readonly MlG4dn8xlarge: "ml.g4dn.8xlarge";
    readonly MlG4dn12xlarge: "ml.g4dn.12xlarge";
    readonly MlG4dn16xlarge: "ml.g4dn.16xlarge";
    readonly MlR5Large: "ml.r5.large";
    readonly MlR5Xlarge: "ml.r5.xlarge";
    readonly MlR52xlarge: "ml.r5.2xlarge";
    readonly MlR54xlarge: "ml.r5.4xlarge";
    readonly MlR58xlarge: "ml.r5.8xlarge";
    readonly MlR512xlarge: "ml.r5.12xlarge";
    readonly MlR516xlarge: "ml.r5.16xlarge";
    readonly MlR524xlarge: "ml.r5.24xlarge";
    readonly MlP3dn24xlarge: "ml.p3dn.24xlarge";
    readonly MlM5dLarge: "ml.m5d.large";
    readonly MlM5dXlarge: "ml.m5d.xlarge";
    readonly MlM5d2xlarge: "ml.m5d.2xlarge";
    readonly MlM5d4xlarge: "ml.m5d.4xlarge";
    readonly MlM5d8xlarge: "ml.m5d.8xlarge";
    readonly MlM5d12xlarge: "ml.m5d.12xlarge";
    readonly MlM5d16xlarge: "ml.m5d.16xlarge";
    readonly MlM5d24xlarge: "ml.m5d.24xlarge";
    readonly MlG5Xlarge: "ml.g5.xlarge";
    readonly MlG52xlarge: "ml.g5.2xlarge";
    readonly MlG54xlarge: "ml.g5.4xlarge";
    readonly MlG58xlarge: "ml.g5.8xlarge";
    readonly MlG512xlarge: "ml.g5.12xlarge";
    readonly MlG516xlarge: "ml.g5.16xlarge";
    readonly MlG524xlarge: "ml.g5.24xlarge";
    readonly MlG548xlarge: "ml.g5.48xlarge";
    readonly MlP4d24xlarge: "ml.p4d.24xlarge";
    readonly MlP4de24xlarge: "ml.p4de.24xlarge";
    readonly MlGeospatialInteractive: "ml.geospatial.interactive";
    readonly MlTrn12xlarge: "ml.trn1.2xlarge";
    readonly MlTrn132xlarge: "ml.trn1.32xlarge";
    readonly MlTrn1n32xlarge: "ml.trn1n.32xlarge";
};
/**
 * The instance type that the image version runs on.
 */
export type DomainResourceSpecInstanceType = (typeof DomainResourceSpecInstanceType)[keyof typeof DomainResourceSpecInstanceType];
export declare const DomainSettingsExecutionRoleIdentityConfig: {
    readonly UserProfileName: "USER_PROFILE_NAME";
    readonly Disabled: "DISABLED";
};
/**
 * The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key.
 */
export type DomainSettingsExecutionRoleIdentityConfig = (typeof DomainSettingsExecutionRoleIdentityConfig)[keyof typeof DomainSettingsExecutionRoleIdentityConfig];
export declare const DomainSharingSettingsNotebookOutputOption: {
    readonly Allowed: "Allowed";
    readonly Disabled: "Disabled";
};
/**
 * Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
 */
export type DomainSharingSettingsNotebookOutputOption = (typeof DomainSharingSettingsNotebookOutputOption)[keyof typeof DomainSharingSettingsNotebookOutputOption];
export declare const DomainTagPropagation: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * Indicates whether the tags added to Domain, User Profile and Space entity is propagated to all SageMaker resources.
 */
export type DomainTagPropagation = (typeof DomainTagPropagation)[keyof typeof DomainTagPropagation];
export declare const DomainUserSettingsStudioWebPortal: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
 */
export type DomainUserSettingsStudioWebPortal = (typeof DomainUserSettingsStudioWebPortal)[keyof typeof DomainUserSettingsStudioWebPortal];
export declare const FeatureGroupFeatureDefinitionFeatureType: {
    readonly Integral: "Integral";
    readonly Fractional: "Fractional";
    readonly String: "String";
};
/**
 * The value type of a feature. Valid values are Integral, Fractional, or String.
 */
export type FeatureGroupFeatureDefinitionFeatureType = (typeof FeatureGroupFeatureDefinitionFeatureType)[keyof typeof FeatureGroupFeatureDefinitionFeatureType];
export declare const FeatureGroupStorageType: {
    readonly Standard: "Standard";
    readonly InMemory: "InMemory";
};
export type FeatureGroupStorageType = (typeof FeatureGroupStorageType)[keyof typeof FeatureGroupStorageType];
export declare const FeatureGroupTableFormat: {
    readonly Iceberg: "Iceberg";
    readonly Glue: "Glue";
};
/**
 * Format for the offline store feature group. Iceberg is the optimal format for feature groups shared between offline and online stores.
 */
export type FeatureGroupTableFormat = (typeof FeatureGroupTableFormat)[keyof typeof FeatureGroupTableFormat];
export declare const FeatureGroupThroughputMode: {
    readonly OnDemand: "OnDemand";
    readonly Provisioned: "Provisioned";
};
/**
 * Throughput mode configuration of the feature group
 */
export type FeatureGroupThroughputMode = (typeof FeatureGroupThroughputMode)[keyof typeof FeatureGroupThroughputMode];
export declare const FeatureGroupUnit: {
    readonly Seconds: "Seconds";
    readonly Minutes: "Minutes";
    readonly Hours: "Hours";
    readonly Days: "Days";
    readonly Weeks: "Weeks";
};
/**
 * Unit of ttl configuration
 */
export type FeatureGroupUnit = (typeof FeatureGroupUnit)[keyof typeof FeatureGroupUnit];
export declare const ImageVersionJobType: {
    readonly Training: "TRAINING";
    readonly Inference: "INFERENCE";
    readonly NotebookKernel: "NOTEBOOK_KERNEL";
};
/**
 * Indicates SageMaker job type compatibility.
 */
export type ImageVersionJobType = (typeof ImageVersionJobType)[keyof typeof ImageVersionJobType];
export declare const ImageVersionProcessor: {
    readonly Cpu: "CPU";
    readonly Gpu: "GPU";
};
/**
 * Indicates CPU or GPU compatibility.
 */
export type ImageVersionProcessor = (typeof ImageVersionProcessor)[keyof typeof ImageVersionProcessor];
export declare const ImageVersionVendorGuidance: {
    readonly NotProvided: "NOT_PROVIDED";
    readonly Stable: "STABLE";
    readonly ToBeArchived: "TO_BE_ARCHIVED";
    readonly Archived: "ARCHIVED";
};
/**
 * The availability of the image version specified by the maintainer.
 */
export type ImageVersionVendorGuidance = (typeof ImageVersionVendorGuidance)[keyof typeof ImageVersionVendorGuidance];
export declare const InferenceComponentStatus: {
    readonly InService: "InService";
    readonly Creating: "Creating";
    readonly Updating: "Updating";
    readonly Failed: "Failed";
    readonly Deleting: "Deleting";
};
export type InferenceComponentStatus = (typeof InferenceComponentStatus)[keyof typeof InferenceComponentStatus];
export declare const InferenceExperimentDesiredState: {
    readonly Running: "Running";
    readonly Completed: "Completed";
    readonly Cancelled: "Cancelled";
};
/**
 * The desired state of the experiment after starting or stopping operation.
 */
export type InferenceExperimentDesiredState = (typeof InferenceExperimentDesiredState)[keyof typeof InferenceExperimentDesiredState];
export declare const InferenceExperimentEndpointMetadataEndpointStatus: {
    readonly Creating: "Creating";
    readonly Updating: "Updating";
    readonly SystemUpdating: "SystemUpdating";
    readonly RollingBack: "RollingBack";
    readonly InService: "InService";
    readonly OutOfService: "OutOfService";
    readonly Deleting: "Deleting";
    readonly Failed: "Failed";
};
/**
 * The status of the endpoint. For possible values of the status of an endpoint.
 */
export type InferenceExperimentEndpointMetadataEndpointStatus = (typeof InferenceExperimentEndpointMetadataEndpointStatus)[keyof typeof InferenceExperimentEndpointMetadataEndpointStatus];
export declare const InferenceExperimentModelInfrastructureConfigInfrastructureType: {
    readonly RealTimeInference: "RealTimeInference";
};
/**
 * The type of the inference experiment that you want to run.
 */
export type InferenceExperimentModelInfrastructureConfigInfrastructureType = (typeof InferenceExperimentModelInfrastructureConfigInfrastructureType)[keyof typeof InferenceExperimentModelInfrastructureConfigInfrastructureType];
export declare const InferenceExperimentStatus: {
    readonly Creating: "Creating";
    readonly Created: "Created";
    readonly Updating: "Updating";
    readonly Starting: "Starting";
    readonly Stopping: "Stopping";
    readonly Running: "Running";
    readonly Completed: "Completed";
    readonly Cancelled: "Cancelled";
};
/**
 * The status of the inference experiment.
 */
export type InferenceExperimentStatus = (typeof InferenceExperimentStatus)[keyof typeof InferenceExperimentStatus];
export declare const InferenceExperimentType: {
    readonly ShadowMode: "ShadowMode";
};
/**
 * The type of the inference experiment that you want to run.
 */
export type InferenceExperimentType = (typeof InferenceExperimentType)[keyof typeof InferenceExperimentType];
export declare const MlflowTrackingServerTrackingServerSize: {
    readonly Small: "Small";
    readonly Medium: "Medium";
    readonly Large: "Large";
};
/**
 * The size of the MLFlow Tracking Server.
 */
export type MlflowTrackingServerTrackingServerSize = (typeof MlflowTrackingServerTrackingServerSize)[keyof typeof MlflowTrackingServerTrackingServerSize];
export declare const ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType = (typeof ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType)[keyof typeof ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType];
export declare const ModelBiasJobDefinitionBatchTransformInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type ModelBiasJobDefinitionBatchTransformInputS3InputMode = (typeof ModelBiasJobDefinitionBatchTransformInputS3InputMode)[keyof typeof ModelBiasJobDefinitionBatchTransformInputS3InputMode];
export declare const ModelBiasJobDefinitionEndpointInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type ModelBiasJobDefinitionEndpointInputS3DataDistributionType = (typeof ModelBiasJobDefinitionEndpointInputS3DataDistributionType)[keyof typeof ModelBiasJobDefinitionEndpointInputS3DataDistributionType];
export declare const ModelBiasJobDefinitionEndpointInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type ModelBiasJobDefinitionEndpointInputS3InputMode = (typeof ModelBiasJobDefinitionEndpointInputS3InputMode)[keyof typeof ModelBiasJobDefinitionEndpointInputS3InputMode];
export declare const ModelBiasJobDefinitionS3OutputS3UploadMode: {
    readonly Continuous: "Continuous";
    readonly EndOfJob: "EndOfJob";
};
/**
 * Whether to upload the results of the monitoring job continuously or after the job completes.
 */
export type ModelBiasJobDefinitionS3OutputS3UploadMode = (typeof ModelBiasJobDefinitionS3OutputS3UploadMode)[keyof typeof ModelBiasJobDefinitionS3OutputS3UploadMode];
export declare const ModelCardBarChartMetricType: {
    readonly BarChart: "bar_chart";
};
export type ModelCardBarChartMetricType = (typeof ModelCardBarChartMetricType)[keyof typeof ModelCardBarChartMetricType];
export declare const ModelCardLinearGraphMetricType: {
    readonly LinearGraph: "linear_graph";
};
export type ModelCardLinearGraphMetricType = (typeof ModelCardLinearGraphMetricType)[keyof typeof ModelCardLinearGraphMetricType];
export declare const ModelCardMatrixMetricType: {
    readonly Matrix: "matrix";
};
export type ModelCardMatrixMetricType = (typeof ModelCardMatrixMetricType)[keyof typeof ModelCardMatrixMetricType];
export declare const ModelCardModelPackageDetailsModelApprovalStatus: {
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly PendingManualApproval: "PendingManualApproval";
};
/**
 * Current approval status of model package
 */
export type ModelCardModelPackageDetailsModelApprovalStatus = (typeof ModelCardModelPackageDetailsModelApprovalStatus)[keyof typeof ModelCardModelPackageDetailsModelApprovalStatus];
export declare const ModelCardModelPackageDetailsModelPackageStatus: {
    readonly Pending: "Pending";
    readonly InProgress: "InProgress";
    readonly Completed: "Completed";
    readonly Failed: "Failed";
    readonly Deleting: "Deleting";
};
/**
 * Current status of model package
 */
export type ModelCardModelPackageDetailsModelPackageStatus = (typeof ModelCardModelPackageDetailsModelPackageStatus)[keyof typeof ModelCardModelPackageDetailsModelPackageStatus];
export declare const ModelCardObjectiveFunctionFunctionPropertiesFunction: {
    readonly Maximize: "Maximize";
    readonly Minimize: "Minimize";
};
export type ModelCardObjectiveFunctionFunctionPropertiesFunction = (typeof ModelCardObjectiveFunctionFunctionPropertiesFunction)[keyof typeof ModelCardObjectiveFunctionFunctionPropertiesFunction];
export declare const ModelCardProcessingStatus: {
    readonly UnsetValue: "UnsetValue";
    readonly DeleteInProgress: "DeleteInProgress";
    readonly DeletePending: "DeletePending";
    readonly ContentDeleted: "ContentDeleted";
    readonly ExportJobsDeleted: "ExportJobsDeleted";
    readonly DeleteCompleted: "DeleteCompleted";
    readonly DeleteFailed: "DeleteFailed";
};
/**
 * The processing status of model card deletion. The ModelCardProcessingStatus updates throughout the different deletion steps.
 */
export type ModelCardProcessingStatus = (typeof ModelCardProcessingStatus)[keyof typeof ModelCardProcessingStatus];
export declare const ModelCardRiskRating: {
    readonly High: "High";
    readonly Medium: "Medium";
    readonly Low: "Low";
    readonly Unknown: "Unknown";
};
/**
 * Risk rating of model.
 */
export type ModelCardRiskRating = (typeof ModelCardRiskRating)[keyof typeof ModelCardRiskRating];
export declare const ModelCardSimpleMetricType: {
    readonly Number: "number";
    readonly String: "string";
    readonly Boolean: "boolean";
};
export type ModelCardSimpleMetricType = (typeof ModelCardSimpleMetricType)[keyof typeof ModelCardSimpleMetricType];
export declare const ModelCardStatus: {
    readonly Draft: "Draft";
    readonly PendingReview: "PendingReview";
    readonly Approved: "Approved";
    readonly Archived: "Archived";
};
/**
 * The approval status of the model card within your organization. Different organizations might have different criteria for model card review and approval.
 */
export type ModelCardStatus = (typeof ModelCardStatus)[keyof typeof ModelCardStatus];
export declare const ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType = (typeof ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType)[keyof typeof ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType];
export declare const ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode = (typeof ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode)[keyof typeof ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode];
export declare const ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType = (typeof ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType)[keyof typeof ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType];
export declare const ModelExplainabilityJobDefinitionEndpointInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type ModelExplainabilityJobDefinitionEndpointInputS3InputMode = (typeof ModelExplainabilityJobDefinitionEndpointInputS3InputMode)[keyof typeof ModelExplainabilityJobDefinitionEndpointInputS3InputMode];
export declare const ModelExplainabilityJobDefinitionS3OutputS3UploadMode: {
    readonly Continuous: "Continuous";
    readonly EndOfJob: "EndOfJob";
};
/**
 * Whether to upload the results of the monitoring job continuously or after the job completes.
 */
export type ModelExplainabilityJobDefinitionS3OutputS3UploadMode = (typeof ModelExplainabilityJobDefinitionS3OutputS3UploadMode)[keyof typeof ModelExplainabilityJobDefinitionS3OutputS3UploadMode];
export declare const ModelPackageGroupStatus: {
    readonly Pending: "Pending";
    readonly InProgress: "InProgress";
    readonly Completed: "Completed";
    readonly Failed: "Failed";
    readonly Deleting: "Deleting";
    readonly DeleteFailed: "DeleteFailed";
};
/**
 * The status of a modelpackage group job.
 */
export type ModelPackageGroupStatus = (typeof ModelPackageGroupStatus)[keyof typeof ModelPackageGroupStatus];
export declare const ModelPackageModelApprovalStatus: {
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly PendingManualApproval: "PendingManualApproval";
};
/**
 * The approval status of the model package.
 */
export type ModelPackageModelApprovalStatus = (typeof ModelPackageModelApprovalStatus)[keyof typeof ModelPackageModelApprovalStatus];
export declare const ModelPackageModelCardModelCardStatus: {
    readonly Draft: "Draft";
    readonly PendingReview: "PendingReview";
    readonly Approved: "Approved";
    readonly Archived: "Archived";
};
/**
 * The approval status of the model card within your organization.
 */
export type ModelPackageModelCardModelCardStatus = (typeof ModelPackageModelCardModelCardStatus)[keyof typeof ModelPackageModelCardModelCardStatus];
export declare const ModelPackageS3DataSourceS3DataType: {
    readonly ManifestFile: "ManifestFile";
    readonly S3Prefix: "S3Prefix";
    readonly AugmentedManifestFile: "AugmentedManifestFile";
};
/**
 * The S3 Data Source Type
 */
export type ModelPackageS3DataSourceS3DataType = (typeof ModelPackageS3DataSourceS3DataType)[keyof typeof ModelPackageS3DataSourceS3DataType];
export declare const ModelPackageS3ModelDataSourceCompressionType: {
    readonly None: "None";
    readonly Gzip: "Gzip";
};
/**
 * Specifies how the ML model data is prepared.
 */
export type ModelPackageS3ModelDataSourceCompressionType = (typeof ModelPackageS3ModelDataSourceCompressionType)[keyof typeof ModelPackageS3ModelDataSourceCompressionType];
export declare const ModelPackageS3ModelDataSourceS3DataType: {
    readonly S3Prefix: "S3Prefix";
    readonly S3Object: "S3Object";
};
/**
 * Specifies the type of ML model data to deploy.
 */
export type ModelPackageS3ModelDataSourceS3DataType = (typeof ModelPackageS3ModelDataSourceS3DataType)[keyof typeof ModelPackageS3ModelDataSourceS3DataType];
export declare const ModelPackageSkipModelValidation: {
    readonly None: "None";
    readonly All: "All";
};
/**
 * Indicates if you want to skip model validation.
 */
export type ModelPackageSkipModelValidation = (typeof ModelPackageSkipModelValidation)[keyof typeof ModelPackageSkipModelValidation];
export declare const ModelPackageStatus: {
    readonly Pending: "Pending";
    readonly Deleting: "Deleting";
    readonly InProgress: "InProgress";
    readonly Completed: "Completed";
    readonly Failed: "Failed";
};
/**
 * The current status of the model package.
 */
export type ModelPackageStatus = (typeof ModelPackageStatus)[keyof typeof ModelPackageStatus];
export declare const ModelPackageStatusItemStatus: {
    readonly NotStarted: "NotStarted";
    readonly Failed: "Failed";
    readonly InProgress: "InProgress";
    readonly Completed: "Completed";
};
/**
 * The current status.
 */
export type ModelPackageStatusItemStatus = (typeof ModelPackageStatusItemStatus)[keyof typeof ModelPackageStatusItemStatus];
export declare const ModelPackageTransformInputCompressionType: {
    readonly None: "None";
    readonly Gzip: "Gzip";
};
/**
 * If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
 */
export type ModelPackageTransformInputCompressionType = (typeof ModelPackageTransformInputCompressionType)[keyof typeof ModelPackageTransformInputCompressionType];
export declare const ModelPackageTransformInputSplitType: {
    readonly None: "None";
    readonly TfRecord: "TFRecord";
    readonly Line: "Line";
    readonly RecordIo: "RecordIO";
};
/**
 * The method to use to split the transform job's data files into smaller batches.
 */
export type ModelPackageTransformInputSplitType = (typeof ModelPackageTransformInputSplitType)[keyof typeof ModelPackageTransformInputSplitType];
export declare const ModelPackageTransformJobDefinitionBatchStrategy: {
    readonly MultiRecord: "MultiRecord";
    readonly SingleRecord: "SingleRecord";
};
/**
 * A string that determines the number of records included in a single mini-batch.
 */
export type ModelPackageTransformJobDefinitionBatchStrategy = (typeof ModelPackageTransformJobDefinitionBatchStrategy)[keyof typeof ModelPackageTransformJobDefinitionBatchStrategy];
export declare const ModelPackageTransformOutputAssembleWith: {
    readonly None: "None";
    readonly Line: "Line";
};
/**
 * Defines how to assemble the results of the transform job as a single S3 object.
 */
export type ModelPackageTransformOutputAssembleWith = (typeof ModelPackageTransformOutputAssembleWith)[keyof typeof ModelPackageTransformOutputAssembleWith];
export declare const ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType = (typeof ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType)[keyof typeof ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType];
export declare const ModelQualityJobDefinitionBatchTransformInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type ModelQualityJobDefinitionBatchTransformInputS3InputMode = (typeof ModelQualityJobDefinitionBatchTransformInputS3InputMode)[keyof typeof ModelQualityJobDefinitionBatchTransformInputS3InputMode];
export declare const ModelQualityJobDefinitionEndpointInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type ModelQualityJobDefinitionEndpointInputS3DataDistributionType = (typeof ModelQualityJobDefinitionEndpointInputS3DataDistributionType)[keyof typeof ModelQualityJobDefinitionEndpointInputS3DataDistributionType];
export declare const ModelQualityJobDefinitionEndpointInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type ModelQualityJobDefinitionEndpointInputS3InputMode = (typeof ModelQualityJobDefinitionEndpointInputS3InputMode)[keyof typeof ModelQualityJobDefinitionEndpointInputS3InputMode];
export declare const ModelQualityJobDefinitionProblemType: {
    readonly BinaryClassification: "BinaryClassification";
    readonly MulticlassClassification: "MulticlassClassification";
    readonly Regression: "Regression";
};
/**
 * The status of the monitoring job.
 */
export type ModelQualityJobDefinitionProblemType = (typeof ModelQualityJobDefinitionProblemType)[keyof typeof ModelQualityJobDefinitionProblemType];
export declare const ModelQualityJobDefinitionS3OutputS3UploadMode: {
    readonly Continuous: "Continuous";
    readonly EndOfJob: "EndOfJob";
};
/**
 * Whether to upload the results of the monitoring job continuously or after the job completes.
 */
export type ModelQualityJobDefinitionS3OutputS3UploadMode = (typeof ModelQualityJobDefinitionS3OutputS3UploadMode)[keyof typeof ModelQualityJobDefinitionS3OutputS3UploadMode];
export declare const MonitoringScheduleBatchTransformInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type MonitoringScheduleBatchTransformInputS3DataDistributionType = (typeof MonitoringScheduleBatchTransformInputS3DataDistributionType)[keyof typeof MonitoringScheduleBatchTransformInputS3DataDistributionType];
export declare const MonitoringScheduleBatchTransformInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type MonitoringScheduleBatchTransformInputS3InputMode = (typeof MonitoringScheduleBatchTransformInputS3InputMode)[keyof typeof MonitoringScheduleBatchTransformInputS3InputMode];
export declare const MonitoringScheduleEndpointInputS3DataDistributionType: {
    readonly FullyReplicated: "FullyReplicated";
    readonly ShardedByS3Key: "ShardedByS3Key";
};
/**
 * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
 */
export type MonitoringScheduleEndpointInputS3DataDistributionType = (typeof MonitoringScheduleEndpointInputS3DataDistributionType)[keyof typeof MonitoringScheduleEndpointInputS3DataDistributionType];
export declare const MonitoringScheduleEndpointInputS3InputMode: {
    readonly Pipe: "Pipe";
    readonly File: "File";
};
/**
 * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
 */
export type MonitoringScheduleEndpointInputS3InputMode = (typeof MonitoringScheduleEndpointInputS3InputMode)[keyof typeof MonitoringScheduleEndpointInputS3InputMode];
export declare const MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus: {
    readonly Pending: "Pending";
    readonly Completed: "Completed";
    readonly CompletedWithViolations: "CompletedWithViolations";
    readonly InProgress: "InProgress";
    readonly Failed: "Failed";
    readonly Stopping: "Stopping";
    readonly Stopped: "Stopped";
};
/**
 * The status of the monitoring job.
 */
export type MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus = (typeof MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus)[keyof typeof MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus];
export declare const MonitoringScheduleMonitoringType: {
    readonly DataQuality: "DataQuality";
    readonly ModelQuality: "ModelQuality";
    readonly ModelBias: "ModelBias";
    readonly ModelExplainability: "ModelExplainability";
};
/**
 * The type of monitoring job.
 */
export type MonitoringScheduleMonitoringType = (typeof MonitoringScheduleMonitoringType)[keyof typeof MonitoringScheduleMonitoringType];
export declare const MonitoringScheduleS3OutputS3UploadMode: {
    readonly Continuous: "Continuous";
    readonly EndOfJob: "EndOfJob";
};
/**
 * Whether to upload the results of the monitoring job continuously or after the job completes.
 */
export type MonitoringScheduleS3OutputS3UploadMode = (typeof MonitoringScheduleS3OutputS3UploadMode)[keyof typeof MonitoringScheduleS3OutputS3UploadMode];
export declare const MonitoringScheduleStatus: {
    readonly Pending: "Pending";
    readonly Failed: "Failed";
    readonly Scheduled: "Scheduled";
    readonly Stopped: "Stopped";
};
/**
 * The status of a schedule job.
 */
export type MonitoringScheduleStatus = (typeof MonitoringScheduleStatus)[keyof typeof MonitoringScheduleStatus];
export declare const PartnerAppAuthType: {
    readonly Iam: "IAM";
};
/**
 * The Auth type of PartnerApp.
 */
export type PartnerAppAuthType = (typeof PartnerAppAuthType)[keyof typeof PartnerAppAuthType];
export declare const PartnerAppType: {
    readonly LakeraGuard: "lakera-guard";
    readonly Comet: "comet";
    readonly DeepchecksLlmEvaluation: "deepchecks-llm-evaluation";
    readonly Fiddler: "fiddler";
};
/**
 * The type of PartnerApp.
 */
export type PartnerAppType = (typeof PartnerAppType)[keyof typeof PartnerAppType];
export declare const ProjectStatus: {
    readonly Pending: "Pending";
    readonly CreateInProgress: "CreateInProgress";
    readonly CreateCompleted: "CreateCompleted";
    readonly CreateFailed: "CreateFailed";
    readonly DeleteInProgress: "DeleteInProgress";
    readonly DeleteFailed: "DeleteFailed";
    readonly DeleteCompleted: "DeleteCompleted";
};
/**
 * The status of a project.
 */
export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus];
export declare const SpaceAppType: {
    readonly JupyterServer: "JupyterServer";
    readonly KernelGateway: "KernelGateway";
    readonly TensorBoard: "TensorBoard";
    readonly RStudioServerPro: "RStudioServerPro";
    readonly RSessionGateway: "RSessionGateway";
    readonly JupyterLab: "JupyterLab";
    readonly CodeEditor: "CodeEditor";
};
export type SpaceAppType = (typeof SpaceAppType)[keyof typeof SpaceAppType];
export declare const SpaceResourceSpecInstanceType: {
    readonly System: "system";
    readonly MlT3Micro: "ml.t3.micro";
    readonly MlT3Small: "ml.t3.small";
    readonly MlT3Medium: "ml.t3.medium";
    readonly MlT3Large: "ml.t3.large";
    readonly MlT3Xlarge: "ml.t3.xlarge";
    readonly MlT32xlarge: "ml.t3.2xlarge";
    readonly MlM5Large: "ml.m5.large";
    readonly MlM5Xlarge: "ml.m5.xlarge";
    readonly MlM52xlarge: "ml.m5.2xlarge";
    readonly MlM54xlarge: "ml.m5.4xlarge";
    readonly MlM58xlarge: "ml.m5.8xlarge";
    readonly MlM512xlarge: "ml.m5.12xlarge";
    readonly MlM516xlarge: "ml.m5.16xlarge";
    readonly MlM524xlarge: "ml.m5.24xlarge";
    readonly MlC5Large: "ml.c5.large";
    readonly MlC5Xlarge: "ml.c5.xlarge";
    readonly MlC52xlarge: "ml.c5.2xlarge";
    readonly MlC54xlarge: "ml.c5.4xlarge";
    readonly MlC59xlarge: "ml.c5.9xlarge";
    readonly MlC512xlarge: "ml.c5.12xlarge";
    readonly MlC518xlarge: "ml.c5.18xlarge";
    readonly MlC524xlarge: "ml.c5.24xlarge";
    readonly MlP32xlarge: "ml.p3.2xlarge";
    readonly MlP38xlarge: "ml.p3.8xlarge";
    readonly MlP316xlarge: "ml.p3.16xlarge";
    readonly MlG4dnXlarge: "ml.g4dn.xlarge";
    readonly MlG4dn2xlarge: "ml.g4dn.2xlarge";
    readonly MlG4dn4xlarge: "ml.g4dn.4xlarge";
    readonly MlG4dn8xlarge: "ml.g4dn.8xlarge";
    readonly MlG4dn12xlarge: "ml.g4dn.12xlarge";
    readonly MlG4dn16xlarge: "ml.g4dn.16xlarge";
    readonly MlR5Large: "ml.r5.large";
    readonly MlR5Xlarge: "ml.r5.xlarge";
    readonly MlR52xlarge: "ml.r5.2xlarge";
    readonly MlR54xlarge: "ml.r5.4xlarge";
    readonly MlR58xlarge: "ml.r5.8xlarge";
    readonly MlR512xlarge: "ml.r5.12xlarge";
    readonly MlR516xlarge: "ml.r5.16xlarge";
    readonly MlR524xlarge: "ml.r5.24xlarge";
    readonly MlP3dn24xlarge: "ml.p3dn.24xlarge";
    readonly MlM5dLarge: "ml.m5d.large";
    readonly MlM5dXlarge: "ml.m5d.xlarge";
    readonly MlM5d2xlarge: "ml.m5d.2xlarge";
    readonly MlM5d4xlarge: "ml.m5d.4xlarge";
    readonly MlM5d8xlarge: "ml.m5d.8xlarge";
    readonly MlM5d12xlarge: "ml.m5d.12xlarge";
    readonly MlM5d16xlarge: "ml.m5d.16xlarge";
    readonly MlM5d24xlarge: "ml.m5d.24xlarge";
    readonly MlG5Xlarge: "ml.g5.xlarge";
    readonly MlG52xlarge: "ml.g5.2xlarge";
    readonly MlG54xlarge: "ml.g5.4xlarge";
    readonly MlG58xlarge: "ml.g5.8xlarge";
    readonly MlG512xlarge: "ml.g5.12xlarge";
    readonly MlG516xlarge: "ml.g5.16xlarge";
    readonly MlG524xlarge: "ml.g5.24xlarge";
    readonly MlG548xlarge: "ml.g5.48xlarge";
    readonly MlP4d24xlarge: "ml.p4d.24xlarge";
    readonly MlP4de24xlarge: "ml.p4de.24xlarge";
    readonly MlGeospatialInteractive: "ml.geospatial.interactive";
    readonly MlTrn12xlarge: "ml.trn1.2xlarge";
    readonly MlTrn132xlarge: "ml.trn1.32xlarge";
    readonly MlTrn1n32xlarge: "ml.trn1n.32xlarge";
};
/**
 * The instance type that the image version runs on.
 */
export type SpaceResourceSpecInstanceType = (typeof SpaceResourceSpecInstanceType)[keyof typeof SpaceResourceSpecInstanceType];
export declare const SpaceSharingSettingsSharingType: {
    readonly Private: "Private";
    readonly Shared: "Shared";
};
/**
 * Specifies the sharing type of the space.
 */
export type SpaceSharingSettingsSharingType = (typeof SpaceSharingSettingsSharingType)[keyof typeof SpaceSharingSettingsSharingType];
export declare const StudioLifecycleConfigAppType: {
    readonly JupyterServer: "JupyterServer";
    readonly KernelGateway: "KernelGateway";
    readonly CodeEditor: "CodeEditor";
    readonly JupyterLab: "JupyterLab";
};
/**
 * The App type that the Lifecycle Configuration is attached to.
 */
export type StudioLifecycleConfigAppType = (typeof StudioLifecycleConfigAppType)[keyof typeof StudioLifecycleConfigAppType];
export declare const UserProfileAppType: {
    readonly JupyterServer: "JupyterServer";
    readonly TensorBoard: "TensorBoard";
    readonly RStudioServerPro: "RStudioServerPro";
    readonly JupyterLab: "JupyterLab";
    readonly CodeEditor: "CodeEditor";
    readonly DetailedProfiler: "DetailedProfiler";
    readonly Canvas: "Canvas";
};
export type UserProfileAppType = (typeof UserProfileAppType)[keyof typeof UserProfileAppType];
export declare const UserProfileLifecycleManagement: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * A flag to enable/disable AppLifecycleManagement settings
 */
export type UserProfileLifecycleManagement = (typeof UserProfileLifecycleManagement)[keyof typeof UserProfileLifecycleManagement];
export declare const UserProfileMlTools: {
    readonly DataWrangler: "DataWrangler";
    readonly FeatureStore: "FeatureStore";
    readonly EmrClusters: "EmrClusters";
    readonly AutoMl: "AutoMl";
    readonly Experiments: "Experiments";
    readonly Training: "Training";
    readonly ModelEvaluation: "ModelEvaluation";
    readonly Pipelines: "Pipelines";
    readonly Models: "Models";
    readonly JumpStart: "JumpStart";
    readonly InferenceRecommender: "InferenceRecommender";
    readonly Endpoints: "Endpoints";
    readonly Projects: "Projects";
    readonly InferenceOptimization: "InferenceOptimization";
    readonly HyperPodClusters: "HyperPodClusters";
    readonly Comet: "Comet";
    readonly DeepchecksLlmEvaluation: "DeepchecksLLMEvaluation";
    readonly Fiddler: "Fiddler";
    readonly LakeraGuard: "LakeraGuard";
};
export type UserProfileMlTools = (typeof UserProfileMlTools)[keyof typeof UserProfileMlTools];
export declare const UserProfileRStudioServerProAppSettingsAccessStatus: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * Indicates whether the current user has access to the RStudioServerPro app.
 */
export type UserProfileRStudioServerProAppSettingsAccessStatus = (typeof UserProfileRStudioServerProAppSettingsAccessStatus)[keyof typeof UserProfileRStudioServerProAppSettingsAccessStatus];
export declare const UserProfileRStudioServerProAppSettingsUserGroup: {
    readonly RStudioAdmin: "R_STUDIO_ADMIN";
    readonly RStudioUser: "R_STUDIO_USER";
};
/**
 * The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
 */
export type UserProfileRStudioServerProAppSettingsUserGroup = (typeof UserProfileRStudioServerProAppSettingsUserGroup)[keyof typeof UserProfileRStudioServerProAppSettingsUserGroup];
export declare const UserProfileResourceSpecInstanceType: {
    readonly System: "system";
    readonly MlT3Micro: "ml.t3.micro";
    readonly MlT3Small: "ml.t3.small";
    readonly MlT3Medium: "ml.t3.medium";
    readonly MlT3Large: "ml.t3.large";
    readonly MlT3Xlarge: "ml.t3.xlarge";
    readonly MlT32xlarge: "ml.t3.2xlarge";
    readonly MlM5Large: "ml.m5.large";
    readonly MlM5Xlarge: "ml.m5.xlarge";
    readonly MlM52xlarge: "ml.m5.2xlarge";
    readonly MlM54xlarge: "ml.m5.4xlarge";
    readonly MlM58xlarge: "ml.m5.8xlarge";
    readonly MlM512xlarge: "ml.m5.12xlarge";
    readonly MlM516xlarge: "ml.m5.16xlarge";
    readonly MlM524xlarge: "ml.m5.24xlarge";
    readonly MlC5Large: "ml.c5.large";
    readonly MlC5Xlarge: "ml.c5.xlarge";
    readonly MlC52xlarge: "ml.c5.2xlarge";
    readonly MlC54xlarge: "ml.c5.4xlarge";
    readonly MlC59xlarge: "ml.c5.9xlarge";
    readonly MlC512xlarge: "ml.c5.12xlarge";
    readonly MlC518xlarge: "ml.c5.18xlarge";
    readonly MlC524xlarge: "ml.c5.24xlarge";
    readonly MlP32xlarge: "ml.p3.2xlarge";
    readonly MlP38xlarge: "ml.p3.8xlarge";
    readonly MlP316xlarge: "ml.p3.16xlarge";
    readonly MlG4dnXlarge: "ml.g4dn.xlarge";
    readonly MlG4dn2xlarge: "ml.g4dn.2xlarge";
    readonly MlG4dn4xlarge: "ml.g4dn.4xlarge";
    readonly MlG4dn8xlarge: "ml.g4dn.8xlarge";
    readonly MlG4dn12xlarge: "ml.g4dn.12xlarge";
    readonly MlG4dn16xlarge: "ml.g4dn.16xlarge";
    readonly MlR5Large: "ml.r5.large";
    readonly MlR5Xlarge: "ml.r5.xlarge";
    readonly MlR52xlarge: "ml.r5.2xlarge";
    readonly MlR54xlarge: "ml.r5.4xlarge";
    readonly MlR58xlarge: "ml.r5.8xlarge";
    readonly MlR512xlarge: "ml.r5.12xlarge";
    readonly MlR516xlarge: "ml.r5.16xlarge";
    readonly MlR524xlarge: "ml.r5.24xlarge";
    readonly MlP3dn24xlarge: "ml.p3dn.24xlarge";
    readonly MlM5dLarge: "ml.m5d.large";
    readonly MlM5dXlarge: "ml.m5d.xlarge";
    readonly MlM5d2xlarge: "ml.m5d.2xlarge";
    readonly MlM5d4xlarge: "ml.m5d.4xlarge";
    readonly MlM5d8xlarge: "ml.m5d.8xlarge";
    readonly MlM5d12xlarge: "ml.m5d.12xlarge";
    readonly MlM5d16xlarge: "ml.m5d.16xlarge";
    readonly MlM5d24xlarge: "ml.m5d.24xlarge";
    readonly MlG5Xlarge: "ml.g5.xlarge";
    readonly MlG52xlarge: "ml.g5.2xlarge";
    readonly MlG54xlarge: "ml.g5.4xlarge";
    readonly MlG58xlarge: "ml.g5.8xlarge";
    readonly MlG512xlarge: "ml.g5.12xlarge";
    readonly MlG516xlarge: "ml.g5.16xlarge";
    readonly MlG524xlarge: "ml.g5.24xlarge";
    readonly MlG548xlarge: "ml.g5.48xlarge";
    readonly MlP4d24xlarge: "ml.p4d.24xlarge";
    readonly MlP4de24xlarge: "ml.p4de.24xlarge";
    readonly MlGeospatialInteractive: "ml.geospatial.interactive";
    readonly MlTrn12xlarge: "ml.trn1.2xlarge";
    readonly MlTrn132xlarge: "ml.trn1.32xlarge";
    readonly MlTrn1n32xlarge: "ml.trn1n.32xlarge";
};
/**
 * The instance type that the image version runs on.
 */
export type UserProfileResourceSpecInstanceType = (typeof UserProfileResourceSpecInstanceType)[keyof typeof UserProfileResourceSpecInstanceType];
export declare const UserProfileSharingSettingsNotebookOutputOption: {
    readonly Allowed: "Allowed";
    readonly Disabled: "Disabled";
};
/**
 * Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
 */
export type UserProfileSharingSettingsNotebookOutputOption = (typeof UserProfileSharingSettingsNotebookOutputOption)[keyof typeof UserProfileSharingSettingsNotebookOutputOption];
export declare const UserProfileUserSettingsStudioWebPortal: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
 */
export type UserProfileUserSettingsStudioWebPortal = (typeof UserProfileUserSettingsStudioWebPortal)[keyof typeof UserProfileUserSettingsStudioWebPortal];
