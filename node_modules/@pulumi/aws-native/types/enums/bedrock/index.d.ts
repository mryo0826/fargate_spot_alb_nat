export declare const AgentActionGroupSignature: {
    readonly AmazonUserInput: "AMAZON.UserInput";
    readonly AmazonCodeInterpreter: "AMAZON.CodeInterpreter";
};
/**
 * Action Group Signature for a BuiltIn Action
 */
export type AgentActionGroupSignature = (typeof AgentActionGroupSignature)[keyof typeof AgentActionGroupSignature];
export declare const AgentActionGroupState: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * State of the action group
 */
export type AgentActionGroupState = (typeof AgentActionGroupState)[keyof typeof AgentActionGroupState];
export declare const AgentAliasStatus: {
    readonly Creating: "CREATING";
    readonly Prepared: "PREPARED";
    readonly Failed: "FAILED";
    readonly Updating: "UPDATING";
    readonly Deleting: "DELETING";
};
/**
 * The statuses an Agent Alias can be in.
 */
export type AgentAliasStatus = (typeof AgentAliasStatus)[keyof typeof AgentAliasStatus];
export declare const AgentCreationMode: {
    readonly Default: "DEFAULT";
    readonly Overridden: "OVERRIDDEN";
};
/**
 * Creation Mode for Prompt Configuration.
 */
export type AgentCreationMode = (typeof AgentCreationMode)[keyof typeof AgentCreationMode];
export declare const AgentCustomControlMethod: {
    readonly ReturnControl: "RETURN_CONTROL";
};
/**
 * Custom control of action execution
 */
export type AgentCustomControlMethod = (typeof AgentCustomControlMethod)[keyof typeof AgentCustomControlMethod];
export declare const AgentKnowledgeBaseState: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * State of the knowledge base; whether it is enabled or disabled
 */
export type AgentKnowledgeBaseState = (typeof AgentKnowledgeBaseState)[keyof typeof AgentKnowledgeBaseState];
export declare const AgentPromptState: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * Prompt State.
 */
export type AgentPromptState = (typeof AgentPromptState)[keyof typeof AgentPromptState];
export declare const AgentPromptType: {
    readonly PreProcessing: "PRE_PROCESSING";
    readonly Orchestration: "ORCHESTRATION";
    readonly PostProcessing: "POST_PROCESSING";
    readonly KnowledgeBaseResponseGeneration: "KNOWLEDGE_BASE_RESPONSE_GENERATION";
};
/**
 * Prompt Type.
 */
export type AgentPromptType = (typeof AgentPromptType)[keyof typeof AgentPromptType];
export declare const AgentRequireConfirmation: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * ENUM to check if action requires user confirmation
 */
export type AgentRequireConfirmation = (typeof AgentRequireConfirmation)[keyof typeof AgentRequireConfirmation];
export declare const AgentStatus: {
    readonly Creating: "CREATING";
    readonly Preparing: "PREPARING";
    readonly Prepared: "PREPARED";
    readonly NotPrepared: "NOT_PREPARED";
    readonly Deleting: "DELETING";
    readonly Failed: "FAILED";
    readonly Versioning: "VERSIONING";
    readonly Updating: "UPDATING";
};
/**
 * Schema Type for Action APIs.
 */
export type AgentStatus = (typeof AgentStatus)[keyof typeof AgentStatus];
export declare const AgentType: {
    readonly String: "string";
    readonly Number: "number";
    readonly Integer: "integer";
    readonly Boolean: "boolean";
    readonly Array: "array";
};
/**
 * Parameter Type
 */
export type AgentType = (typeof AgentType)[keyof typeof AgentType];
export declare const ApplicationInferenceProfileInferenceProfileStatus: {
    readonly Active: "ACTIVE";
};
/**
 * Status of the Inference Profile
 */
export type ApplicationInferenceProfileInferenceProfileStatus = (typeof ApplicationInferenceProfileInferenceProfileStatus)[keyof typeof ApplicationInferenceProfileInferenceProfileStatus];
export declare const ApplicationInferenceProfileInferenceProfileType: {
    readonly Application: "APPLICATION";
    readonly SystemDefined: "SYSTEM_DEFINED";
};
/**
 * Type of the Inference Profile
 */
export type ApplicationInferenceProfileInferenceProfileType = (typeof ApplicationInferenceProfileInferenceProfileType)[keyof typeof ApplicationInferenceProfileInferenceProfileType];
export declare const DataSourceChunkingStrategy: {
    readonly FixedSize: "FIXED_SIZE";
    readonly None: "NONE";
    readonly Hierarchical: "HIERARCHICAL";
    readonly Semantic: "SEMANTIC";
};
/**
 * Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
 */
export type DataSourceChunkingStrategy = (typeof DataSourceChunkingStrategy)[keyof typeof DataSourceChunkingStrategy];
export declare const DataSourceConfluenceSourceConfigurationAuthType: {
    readonly Basic: "BASIC";
    readonly Oauth2ClientCredentials: "OAUTH2_CLIENT_CREDENTIALS";
};
/**
 * The supported authentication type to authenticate and connect to your Confluence instance.
 */
export type DataSourceConfluenceSourceConfigurationAuthType = (typeof DataSourceConfluenceSourceConfigurationAuthType)[keyof typeof DataSourceConfluenceSourceConfigurationAuthType];
export declare const DataSourceConfluenceSourceConfigurationHostType: {
    readonly Saas: "SAAS";
};
/**
 * The supported host type, whether online/cloud or server/on-premises.
 */
export type DataSourceConfluenceSourceConfigurationHostType = (typeof DataSourceConfluenceSourceConfigurationHostType)[keyof typeof DataSourceConfluenceSourceConfigurationHostType];
export declare const DataSourceCrawlFilterConfigurationType: {
    readonly Pattern: "PATTERN";
};
/**
 * The crawl filter type.
 */
export type DataSourceCrawlFilterConfigurationType = (typeof DataSourceCrawlFilterConfigurationType)[keyof typeof DataSourceCrawlFilterConfigurationType];
export declare const DataSourceDataDeletionPolicy: {
    readonly Retain: "RETAIN";
    readonly Delete: "DELETE";
};
/**
 * The deletion policy for the data source.
 */
export type DataSourceDataDeletionPolicy = (typeof DataSourceDataDeletionPolicy)[keyof typeof DataSourceDataDeletionPolicy];
export declare const DataSourceParsingStrategy: {
    readonly BedrockFoundationModel: "BEDROCK_FOUNDATION_MODEL";
};
/**
 * The parsing strategy for the data source.
 */
export type DataSourceParsingStrategy = (typeof DataSourceParsingStrategy)[keyof typeof DataSourceParsingStrategy];
export declare const DataSourceSalesforceSourceConfigurationAuthType: {
    readonly Oauth2ClientCredentials: "OAUTH2_CLIENT_CREDENTIALS";
};
/**
 * The supported authentication type to authenticate and connect to your Salesforce instance.
 */
export type DataSourceSalesforceSourceConfigurationAuthType = (typeof DataSourceSalesforceSourceConfigurationAuthType)[keyof typeof DataSourceSalesforceSourceConfigurationAuthType];
export declare const DataSourceSharePointSourceConfigurationAuthType: {
    readonly Oauth2ClientCredentials: "OAUTH2_CLIENT_CREDENTIALS";
};
/**
 * The supported authentication type to authenticate and connect to your SharePoint site/sites.
 */
export type DataSourceSharePointSourceConfigurationAuthType = (typeof DataSourceSharePointSourceConfigurationAuthType)[keyof typeof DataSourceSharePointSourceConfigurationAuthType];
export declare const DataSourceSharePointSourceConfigurationHostType: {
    readonly Online: "ONLINE";
};
/**
 * The supported host type, whether online/cloud or server/on-premises.
 */
export type DataSourceSharePointSourceConfigurationHostType = (typeof DataSourceSharePointSourceConfigurationHostType)[keyof typeof DataSourceSharePointSourceConfigurationHostType];
export declare const DataSourceStatus: {
    readonly Available: "AVAILABLE";
    readonly Deleting: "DELETING";
    readonly DeleteUnsuccessful: "DELETE_UNSUCCESSFUL";
};
/**
 * The status of a data source.
 */
export type DataSourceStatus = (typeof DataSourceStatus)[keyof typeof DataSourceStatus];
export declare const DataSourceTransformationStepToApply: {
    readonly PostChunking: "POST_CHUNKING";
};
/**
 * When the service applies the transformation.
 */
export type DataSourceTransformationStepToApply = (typeof DataSourceTransformationStepToApply)[keyof typeof DataSourceTransformationStepToApply];
export declare const DataSourceType: {
    readonly S3: "S3";
    readonly Confluence: "CONFLUENCE";
    readonly Salesforce: "SALESFORCE";
    readonly Sharepoint: "SHAREPOINT";
    readonly Web: "WEB";
};
/**
 * The type of the data source location.
 */
export type DataSourceType = (typeof DataSourceType)[keyof typeof DataSourceType];
export declare const DataSourceWebScopeType: {
    readonly HostOnly: "HOST_ONLY";
    readonly Subdomains: "SUBDOMAINS";
};
/**
 * The scope that a web crawl job will be restricted to.
 */
export type DataSourceWebScopeType = (typeof DataSourceWebScopeType)[keyof typeof DataSourceWebScopeType];
export declare const FlowConnectionType: {
    readonly Data: "Data";
    readonly Conditional: "Conditional";
};
/**
 * Connection type
 */
export type FlowConnectionType = (typeof FlowConnectionType)[keyof typeof FlowConnectionType];
export declare const FlowNodeIoDataType: {
    readonly String: "String";
    readonly Number: "Number";
    readonly Boolean: "Boolean";
    readonly Object: "Object";
    readonly Array: "Array";
};
/**
 * Type of input/output for a node in a flow
 */
export type FlowNodeIoDataType = (typeof FlowNodeIoDataType)[keyof typeof FlowNodeIoDataType];
export declare const FlowNodeType: {
    readonly InputType: "Input";
    readonly OutputType: "Output";
    readonly KnowledgeBase: "KnowledgeBase";
    readonly Condition: "Condition";
    readonly Lex: "Lex";
    readonly Prompt: "Prompt";
    readonly LambdaFunction: "LambdaFunction";
    readonly Agent: "Agent";
    readonly Storage: "Storage";
    readonly Retrieval: "Retrieval";
    readonly Iterator: "Iterator";
    readonly Collector: "Collector";
};
/**
 * Flow node types
 */
export type FlowNodeType = (typeof FlowNodeType)[keyof typeof FlowNodeType];
export declare const FlowPromptTemplateType: {
    readonly Text: "TEXT";
};
/**
 * Prompt template type
 */
export type FlowPromptTemplateType = (typeof FlowPromptTemplateType)[keyof typeof FlowPromptTemplateType];
export declare const FlowStatus: {
    readonly Failed: "Failed";
    readonly Prepared: "Prepared";
    readonly Preparing: "Preparing";
    readonly NotPrepared: "NotPrepared";
};
/**
 * Schema Type for Flow APIs
 */
export type FlowStatus = (typeof FlowStatus)[keyof typeof FlowStatus];
export declare const FlowVersionFlowConnectionType: {
    readonly Data: "Data";
    readonly Conditional: "Conditional";
};
/**
 * Connection type
 */
export type FlowVersionFlowConnectionType = (typeof FlowVersionFlowConnectionType)[keyof typeof FlowVersionFlowConnectionType];
export declare const FlowVersionFlowNodeIoDataType: {
    readonly String: "String";
    readonly Number: "Number";
    readonly Boolean: "Boolean";
    readonly Object: "Object";
    readonly Array: "Array";
};
/**
 * Type of input/output for a node in a flow
 */
export type FlowVersionFlowNodeIoDataType = (typeof FlowVersionFlowNodeIoDataType)[keyof typeof FlowVersionFlowNodeIoDataType];
export declare const FlowVersionFlowNodeType: {
    readonly InputType: "Input";
    readonly OutputType: "Output";
    readonly KnowledgeBase: "KnowledgeBase";
    readonly Condition: "Condition";
    readonly Lex: "Lex";
    readonly Prompt: "Prompt";
    readonly LambdaFunction: "LambdaFunction";
    readonly Agent: "Agent";
    readonly Iterator: "Iterator";
    readonly Collector: "Collector";
    readonly Storage: "Storage";
    readonly Retrieval: "Retrieval";
};
/**
 * Flow node types
 */
export type FlowVersionFlowNodeType = (typeof FlowVersionFlowNodeType)[keyof typeof FlowVersionFlowNodeType];
export declare const FlowVersionFlowStatus: {
    readonly Failed: "Failed";
    readonly Prepared: "Prepared";
    readonly Preparing: "Preparing";
    readonly NotPrepared: "NotPrepared";
};
/**
 * Schema Type for Flow APIs
 */
export type FlowVersionFlowStatus = (typeof FlowVersionFlowStatus)[keyof typeof FlowVersionFlowStatus];
export declare const FlowVersionPromptTemplateType: {
    readonly Text: "TEXT";
};
/**
 * Prompt template type
 */
export type FlowVersionPromptTemplateType = (typeof FlowVersionPromptTemplateType)[keyof typeof FlowVersionPromptTemplateType];
export declare const GuardrailContentFilterType: {
    readonly Sexual: "SEXUAL";
    readonly Violence: "VIOLENCE";
    readonly Hate: "HATE";
    readonly Insults: "INSULTS";
    readonly Misconduct: "MISCONDUCT";
    readonly PromptAttack: "PROMPT_ATTACK";
};
/**
 * Type of filter in content policy
 */
export type GuardrailContentFilterType = (typeof GuardrailContentFilterType)[keyof typeof GuardrailContentFilterType];
export declare const GuardrailContextualGroundingFilterType: {
    readonly Grounding: "GROUNDING";
    readonly Relevance: "RELEVANCE";
};
/**
 * Type of contextual grounding filter
 */
export type GuardrailContextualGroundingFilterType = (typeof GuardrailContextualGroundingFilterType)[keyof typeof GuardrailContextualGroundingFilterType];
export declare const GuardrailFilterStrength: {
    readonly None: "NONE";
    readonly Low: "LOW";
    readonly Medium: "MEDIUM";
    readonly High: "HIGH";
};
/**
 * Strength for filters
 */
export type GuardrailFilterStrength = (typeof GuardrailFilterStrength)[keyof typeof GuardrailFilterStrength];
export declare const GuardrailManagedWordsType: {
    readonly Profanity: "PROFANITY";
};
/**
 * Options for managed words.
 */
export type GuardrailManagedWordsType = (typeof GuardrailManagedWordsType)[keyof typeof GuardrailManagedWordsType];
export declare const GuardrailPiiEntityType: {
    readonly Address: "ADDRESS";
    readonly Age: "AGE";
    readonly AwsAccessKey: "AWS_ACCESS_KEY";
    readonly AwsSecretKey: "AWS_SECRET_KEY";
    readonly CaHealthNumber: "CA_HEALTH_NUMBER";
    readonly CaSocialInsuranceNumber: "CA_SOCIAL_INSURANCE_NUMBER";
    readonly CreditDebitCardCvv: "CREDIT_DEBIT_CARD_CVV";
    readonly CreditDebitCardExpiry: "CREDIT_DEBIT_CARD_EXPIRY";
    readonly CreditDebitCardNumber: "CREDIT_DEBIT_CARD_NUMBER";
    readonly DriverId: "DRIVER_ID";
    readonly Email: "EMAIL";
    readonly InternationalBankAccountNumber: "INTERNATIONAL_BANK_ACCOUNT_NUMBER";
    readonly IpAddress: "IP_ADDRESS";
    readonly LicensePlate: "LICENSE_PLATE";
    readonly MacAddress: "MAC_ADDRESS";
    readonly Name: "NAME";
    readonly Password: "PASSWORD";
    readonly Phone: "PHONE";
    readonly Pin: "PIN";
    readonly SwiftCode: "SWIFT_CODE";
    readonly UkNationalHealthServiceNumber: "UK_NATIONAL_HEALTH_SERVICE_NUMBER";
    readonly UkNationalInsuranceNumber: "UK_NATIONAL_INSURANCE_NUMBER";
    readonly UkUniqueTaxpayerReferenceNumber: "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER";
    readonly Url: "URL";
    readonly Username: "USERNAME";
    readonly UsBankAccountNumber: "US_BANK_ACCOUNT_NUMBER";
    readonly UsBankRoutingNumber: "US_BANK_ROUTING_NUMBER";
    readonly UsIndividualTaxIdentificationNumber: "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER";
    readonly UsPassportNumber: "US_PASSPORT_NUMBER";
    readonly UsSocialSecurityNumber: "US_SOCIAL_SECURITY_NUMBER";
    readonly VehicleIdentificationNumber: "VEHICLE_IDENTIFICATION_NUMBER";
};
/**
 * The currently supported PII entities
 */
export type GuardrailPiiEntityType = (typeof GuardrailPiiEntityType)[keyof typeof GuardrailPiiEntityType];
export declare const GuardrailSensitiveInformationAction: {
    readonly Block: "BLOCK";
    readonly Anonymize: "ANONYMIZE";
};
/**
 * Options for sensitive information action.
 */
export type GuardrailSensitiveInformationAction = (typeof GuardrailSensitiveInformationAction)[keyof typeof GuardrailSensitiveInformationAction];
export declare const GuardrailStatus: {
    readonly Creating: "CREATING";
    readonly Updating: "UPDATING";
    readonly Versioning: "VERSIONING";
    readonly Ready: "READY";
    readonly Failed: "FAILED";
    readonly Deleting: "DELETING";
};
/**
 * Status of the guardrail
 */
export type GuardrailStatus = (typeof GuardrailStatus)[keyof typeof GuardrailStatus];
export declare const GuardrailTopicType: {
    readonly Deny: "DENY";
};
/**
 * Type of topic in a policy
 */
export type GuardrailTopicType = (typeof GuardrailTopicType)[keyof typeof GuardrailTopicType];
export declare const KnowledgeBaseStatus: {
    readonly Creating: "CREATING";
    readonly Active: "ACTIVE";
    readonly Deleting: "DELETING";
    readonly Updating: "UPDATING";
    readonly Failed: "FAILED";
    readonly DeleteUnsuccessful: "DELETE_UNSUCCESSFUL";
};
/**
 * The status of a knowledge base.
 */
export type KnowledgeBaseStatus = (typeof KnowledgeBaseStatus)[keyof typeof KnowledgeBaseStatus];
export declare const KnowledgeBaseStorageType: {
    readonly OpensearchServerless: "OPENSEARCH_SERVERLESS";
    readonly Pinecone: "PINECONE";
    readonly Rds: "RDS";
    readonly MongoDbAtlas: "MONGO_DB_ATLAS";
};
/**
 * The storage type of a knowledge base.
 */
export type KnowledgeBaseStorageType = (typeof KnowledgeBaseStorageType)[keyof typeof KnowledgeBaseStorageType];
export declare const KnowledgeBaseType: {
    readonly Vector: "VECTOR";
};
/**
 * The type of a knowledge base.
 */
export type KnowledgeBaseType = (typeof KnowledgeBaseType)[keyof typeof KnowledgeBaseType];
export declare const PromptConversationRole: {
    readonly User: "user";
    readonly Assistant: "assistant";
};
/**
 * Conversation roles for the chat prompt
 */
export type PromptConversationRole = (typeof PromptConversationRole)[keyof typeof PromptConversationRole];
export declare const PromptTemplateType: {
    readonly Text: "TEXT";
    readonly Chat: "CHAT";
};
/**
 * Prompt template type
 */
export type PromptTemplateType = (typeof PromptTemplateType)[keyof typeof PromptTemplateType];
export declare const PromptVersionPromptTemplateType: {
    readonly Text: "TEXT";
};
/**
 * Prompt template type
 */
export type PromptVersionPromptTemplateType = (typeof PromptVersionPromptTemplateType)[keyof typeof PromptVersionPromptTemplateType];
