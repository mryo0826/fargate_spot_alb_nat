export declare const AgentStatusState: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * The state of the status.
 */
export type AgentStatusState = (typeof AgentStatusState)[keyof typeof AgentStatusState];
export declare const AgentStatusType: {
    readonly Routable: "ROUTABLE";
    readonly Custom: "CUSTOM";
    readonly Offline: "OFFLINE";
};
/**
 * The type of agent status.
 */
export type AgentStatusType = (typeof AgentStatusType)[keyof typeof AgentStatusType];
export declare const ContactFlowState: {
    readonly Active: "ACTIVE";
    readonly Archived: "ARCHIVED";
};
/**
 * The state of the contact flow.
 */
export type ContactFlowState = (typeof ContactFlowState)[keyof typeof ContactFlowState];
export declare const ContactFlowType: {
    readonly ContactFlow: "CONTACT_FLOW";
    readonly CustomerQueue: "CUSTOMER_QUEUE";
    readonly CustomerHold: "CUSTOMER_HOLD";
    readonly CustomerWhisper: "CUSTOMER_WHISPER";
    readonly AgentHold: "AGENT_HOLD";
    readonly AgentWhisper: "AGENT_WHISPER";
    readonly OutboundWhisper: "OUTBOUND_WHISPER";
    readonly AgentTransfer: "AGENT_TRANSFER";
    readonly QueueTransfer: "QUEUE_TRANSFER";
    readonly Campaign: "CAMPAIGN";
};
/**
 * The type of the contact flow.
 */
export type ContactFlowType = (typeof ContactFlowType)[keyof typeof ContactFlowType];
export declare const EvaluationFormNumericQuestionPropertyValueAutomationLabel: {
    readonly OverallCustomerSentimentScore: "OVERALL_CUSTOMER_SENTIMENT_SCORE";
    readonly OverallAgentSentimentScore: "OVERALL_AGENT_SENTIMENT_SCORE";
    readonly NonTalkTime: "NON_TALK_TIME";
    readonly NonTalkTimePercentage: "NON_TALK_TIME_PERCENTAGE";
    readonly NumberOfInterruptions: "NUMBER_OF_INTERRUPTIONS";
    readonly ContactDuration: "CONTACT_DURATION";
    readonly AgentInteractionDuration: "AGENT_INTERACTION_DURATION";
    readonly CustomerHoldTime: "CUSTOMER_HOLD_TIME";
};
/**
 * The property label of the automation.
 */
export type EvaluationFormNumericQuestionPropertyValueAutomationLabel = (typeof EvaluationFormNumericQuestionPropertyValueAutomationLabel)[keyof typeof EvaluationFormNumericQuestionPropertyValueAutomationLabel];
export declare const EvaluationFormQuestionQuestionType: {
    readonly Numeric: "NUMERIC";
    readonly Singleselect: "SINGLESELECT";
    readonly Text: "TEXT";
};
/**
 * The type of the question.
 *   *Allowed values*: ``NUMERIC`` | ``SINGLESELECT`` | ``TEXT``
 */
export type EvaluationFormQuestionQuestionType = (typeof EvaluationFormQuestionQuestionType)[keyof typeof EvaluationFormQuestionQuestionType];
export declare const EvaluationFormScoringStrategyMode: {
    readonly QuestionOnly: "QUESTION_ONLY";
    readonly SectionOnly: "SECTION_ONLY";
};
/**
 * The scoring mode of the evaluation form.
 *   *Allowed values*: ``QUESTION_ONLY`` | ``SECTION_ONLY``
 */
export type EvaluationFormScoringStrategyMode = (typeof EvaluationFormScoringStrategyMode)[keyof typeof EvaluationFormScoringStrategyMode];
export declare const EvaluationFormScoringStrategyStatus: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * The scoring status of the evaluation form.
 *   *Allowed values*: ``ENABLED`` | ``DISABLED``
 */
export type EvaluationFormScoringStrategyStatus = (typeof EvaluationFormScoringStrategyStatus)[keyof typeof EvaluationFormScoringStrategyStatus];
export declare const EvaluationFormSingleSelectQuestionPropertiesDisplayAs: {
    readonly Dropdown: "DROPDOWN";
    readonly Radio: "RADIO";
};
/**
 * The display mode of the single select question.
 *   *Allowed values*: ``DROPDOWN`` | ``RADIO``
 */
export type EvaluationFormSingleSelectQuestionPropertiesDisplayAs = (typeof EvaluationFormSingleSelectQuestionPropertiesDisplayAs)[keyof typeof EvaluationFormSingleSelectQuestionPropertiesDisplayAs];
export declare const EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition: {
    readonly Present: "PRESENT";
    readonly NotPresent: "NOT_PRESENT";
};
/**
 * The condition to apply for the automation option. If the condition is PRESENT, then the option is applied when the contact data includes the category. Similarly, if the condition is NOT_PRESENT, then the option is applied when the contact data does not include the category.
 *   *Allowed values*: ``PRESENT`` | ``NOT_PRESENT``
 *   *Maximum*: 50
 */
export type EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition = (typeof EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition)[keyof typeof EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition];
export declare const EvaluationFormStatus: {
    readonly Draft: "DRAFT";
    readonly Active: "ACTIVE";
};
/**
 * The status of the evaluation form.
 *   *Allowed values*: ``DRAFT`` | ``ACTIVE``
 */
export type EvaluationFormStatus = (typeof EvaluationFormStatus)[keyof typeof EvaluationFormStatus];
export declare const HoursOfOperationConfigDay: {
    readonly Sunday: "SUNDAY";
    readonly Monday: "MONDAY";
    readonly Tuesday: "TUESDAY";
    readonly Wednesday: "WEDNESDAY";
    readonly Thursday: "THURSDAY";
    readonly Friday: "FRIDAY";
    readonly Saturday: "SATURDAY";
};
/**
 * The day that the hours of operation applies to.
 */
export type HoursOfOperationConfigDay = (typeof HoursOfOperationConfigDay)[keyof typeof HoursOfOperationConfigDay];
export declare const HoursOfOperationOverrideConfigDay: {
    readonly Sunday: "SUNDAY";
    readonly Monday: "MONDAY";
    readonly Tuesday: "TUESDAY";
    readonly Wednesday: "WEDNESDAY";
    readonly Thursday: "THURSDAY";
    readonly Friday: "FRIDAY";
    readonly Saturday: "SATURDAY";
};
/**
 * The day that the hours of operation override applies to.
 */
export type HoursOfOperationOverrideConfigDay = (typeof HoursOfOperationOverrideConfigDay)[keyof typeof HoursOfOperationOverrideConfigDay];
export declare const InstanceIdentityManagementType: {
    readonly Saml: "SAML";
    readonly ConnectManaged: "CONNECT_MANAGED";
    readonly ExistingDirectory: "EXISTING_DIRECTORY";
};
/**
 * Specifies the type of directory integration for new instance.
 */
export type InstanceIdentityManagementType = (typeof InstanceIdentityManagementType)[keyof typeof InstanceIdentityManagementType];
export declare const InstanceStatus: {
    readonly CreationInProgress: "CREATION_IN_PROGRESS";
    readonly CreationFailed: "CREATION_FAILED";
    readonly Active: "ACTIVE";
};
/**
 * Specifies the creation status of new instance.
 */
export type InstanceStatus = (typeof InstanceStatus)[keyof typeof InstanceStatus];
export declare const InstanceStorageConfigEncryptionType: {
    readonly Kms: "KMS";
};
/**
 * Specifies default encryption using AWS KMS-Managed Keys
 */
export type InstanceStorageConfigEncryptionType = (typeof InstanceStorageConfigEncryptionType)[keyof typeof InstanceStorageConfigEncryptionType];
export declare const InstanceStorageConfigInstanceStorageResourceType: {
    readonly ChatTranscripts: "CHAT_TRANSCRIPTS";
    readonly CallRecordings: "CALL_RECORDINGS";
    readonly ScheduledReports: "SCHEDULED_REPORTS";
    readonly MediaStreams: "MEDIA_STREAMS";
    readonly ContactTraceRecords: "CONTACT_TRACE_RECORDS";
    readonly AgentEvents: "AGENT_EVENTS";
};
/**
 * Specifies the type of storage resource available for the instance
 */
export type InstanceStorageConfigInstanceStorageResourceType = (typeof InstanceStorageConfigInstanceStorageResourceType)[keyof typeof InstanceStorageConfigInstanceStorageResourceType];
export declare const InstanceStorageConfigStorageType: {
    readonly S3: "S3";
    readonly KinesisVideoStream: "KINESIS_VIDEO_STREAM";
    readonly KinesisStream: "KINESIS_STREAM";
    readonly KinesisFirehose: "KINESIS_FIREHOSE";
};
/**
 * Specifies the storage type to be associated with the instance
 */
export type InstanceStorageConfigStorageType = (typeof InstanceStorageConfigStorageType)[keyof typeof InstanceStorageConfigStorageType];
export declare const IntegrationAssociationIntegrationType: {
    readonly LexBot: "LEX_BOT";
    readonly LambdaFunction: "LAMBDA_FUNCTION";
    readonly Application: "APPLICATION";
};
/**
 * Specifies the integration type to be associated with the instance
 */
export type IntegrationAssociationIntegrationType = (typeof IntegrationAssociationIntegrationType)[keyof typeof IntegrationAssociationIntegrationType];
export declare const QueueStatus: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * The status of the queue.
 */
export type QueueStatus = (typeof QueueStatus)[keyof typeof QueueStatus];
export declare const QueueType: {
    readonly Standard: "STANDARD";
    readonly Agent: "AGENT";
};
/**
 * The type of queue.
 */
export type QueueType = (typeof QueueType)[keyof typeof QueueType];
export declare const QuickConnectType: {
    readonly PhoneNumber: "PHONE_NUMBER";
    readonly Queue: "QUEUE";
    readonly User: "USER";
};
/**
 * The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
 */
export type QuickConnectType = (typeof QuickConnectType)[keyof typeof QuickConnectType];
export declare const RoutingProfileAgentAvailabilityTimer: {
    readonly TimeSinceLastActivity: "TIME_SINCE_LAST_ACTIVITY";
    readonly TimeSinceLastInbound: "TIME_SINCE_LAST_INBOUND";
};
/**
 * Whether agents with this routing profile will have their routing order calculated based on longest idle time or time since their last inbound contact.
 */
export type RoutingProfileAgentAvailabilityTimer = (typeof RoutingProfileAgentAvailabilityTimer)[keyof typeof RoutingProfileAgentAvailabilityTimer];
export declare const RoutingProfileBehaviorType: {
    readonly RouteCurrentChannelOnly: "ROUTE_CURRENT_CHANNEL_ONLY";
    readonly RouteAnyChannel: "ROUTE_ANY_CHANNEL";
};
/**
 * Specifies the other channels that can be routed to an agent handling their current channel.
 */
export type RoutingProfileBehaviorType = (typeof RoutingProfileBehaviorType)[keyof typeof RoutingProfileBehaviorType];
export declare const RoutingProfileChannel: {
    readonly Voice: "VOICE";
    readonly Chat: "CHAT";
    readonly Task: "TASK";
};
/**
 * The channels that agents can handle in the Contact Control Panel (CCP).
 */
export type RoutingProfileChannel = (typeof RoutingProfileChannel)[keyof typeof RoutingProfileChannel];
export declare const RulePublishStatus: {
    readonly Draft: "DRAFT";
    readonly Published: "PUBLISHED";
};
/**
 * The publish status of the rule.
 *   *Allowed values*: ``DRAFT`` | ``PUBLISHED``
 */
export type RulePublishStatus = (typeof RulePublishStatus)[keyof typeof RulePublishStatus];
export declare const RuleReferenceType: {
    readonly Url: "URL";
    readonly Attachment: "ATTACHMENT";
    readonly Number: "NUMBER";
    readonly String: "STRING";
    readonly Date: "DATE";
    readonly Email: "EMAIL";
};
/**
 * The type of the reference. ``DATE`` must be of type Epoch timestamp.
 *   *Allowed values*: ``URL`` | ``ATTACHMENT`` | ``NUMBER`` | ``STRING`` | ``DATE`` | ``EMAIL``
 */
export type RuleReferenceType = (typeof RuleReferenceType)[keyof typeof RuleReferenceType];
export declare const RuleSendNotificationActionContentType: {
    readonly PlainText: "PLAIN_TEXT";
};
/**
 * Content type format.
 *   *Allowed value*: ``PLAIN_TEXT``
 */
export type RuleSendNotificationActionContentType = (typeof RuleSendNotificationActionContentType)[keyof typeof RuleSendNotificationActionContentType];
export declare const RuleSendNotificationActionDeliveryMethod: {
    readonly Email: "EMAIL";
};
/**
 * Notification delivery method.
 *   *Allowed value*: ``EMAIL``
 */
export type RuleSendNotificationActionDeliveryMethod = (typeof RuleSendNotificationActionDeliveryMethod)[keyof typeof RuleSendNotificationActionDeliveryMethod];
export declare const RuleTriggerEventSourceEventSourceName: {
    readonly OnContactEvaluationSubmit: "OnContactEvaluationSubmit";
    readonly OnPostCallAnalysisAvailable: "OnPostCallAnalysisAvailable";
    readonly OnRealTimeCallAnalysisAvailable: "OnRealTimeCallAnalysisAvailable";
    readonly OnRealTimeChatAnalysisAvailable: "OnRealTimeChatAnalysisAvailable";
    readonly OnPostChatAnalysisAvailable: "OnPostChatAnalysisAvailable";
    readonly OnZendeskTicketCreate: "OnZendeskTicketCreate";
    readonly OnZendeskTicketStatusUpdate: "OnZendeskTicketStatusUpdate";
    readonly OnSalesforceCaseCreate: "OnSalesforceCaseCreate";
    readonly OnMetricDataUpdate: "OnMetricDataUpdate";
    readonly OnCaseCreate: "OnCaseCreate";
    readonly OnCaseUpdate: "OnCaseUpdate";
};
/**
 * The name of the event source.
 */
export type RuleTriggerEventSourceEventSourceName = (typeof RuleTriggerEventSourceEventSourceName)[keyof typeof RuleTriggerEventSourceEventSourceName];
export declare const TaskTemplateFieldType: {
    readonly Name: "NAME";
    readonly Description: "DESCRIPTION";
    readonly ScheduledTime: "SCHEDULED_TIME";
    readonly QuickConnect: "QUICK_CONNECT";
    readonly Url: "URL";
    readonly Number: "NUMBER";
    readonly Text: "TEXT";
    readonly TextArea: "TEXT_AREA";
    readonly DateTime: "DATE_TIME";
    readonly Boolean: "BOOLEAN";
    readonly SingleSelect: "SINGLE_SELECT";
    readonly Email: "EMAIL";
    readonly ExpiryDuration: "EXPIRY_DURATION";
    readonly SelfAssign: "SELF_ASSIGN";
};
/**
 * The type of the task template's field
 */
export type TaskTemplateFieldType = (typeof TaskTemplateFieldType)[keyof typeof TaskTemplateFieldType];
export declare const TaskTemplateStatus: {
    readonly Active: "ACTIVE";
    readonly Inactive: "INACTIVE";
};
/**
 * The status of the task template
 */
export type TaskTemplateStatus = (typeof TaskTemplateStatus)[keyof typeof TaskTemplateStatus];
export declare const TrafficDistributionGroupStatus: {
    readonly CreationInProgress: "CREATION_IN_PROGRESS";
    readonly Active: "ACTIVE";
    readonly CreationFailed: "CREATION_FAILED";
    readonly PendingDeletion: "PENDING_DELETION";
    readonly DeletionFailed: "DELETION_FAILED";
    readonly UpdateInProgress: "UPDATE_IN_PROGRESS";
};
/**
 * The status of the traffic distribution group.
 */
export type TrafficDistributionGroupStatus = (typeof TrafficDistributionGroupStatus)[keyof typeof TrafficDistributionGroupStatus];
export declare const UserPhoneType: {
    readonly SoftPhone: "SOFT_PHONE";
    readonly DeskPhone: "DESK_PHONE";
};
/**
 * The phone type.
 */
export type UserPhoneType = (typeof UserPhoneType)[keyof typeof UserPhoneType];
