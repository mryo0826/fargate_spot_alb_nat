export declare const BridgeFailoverConfigStateEnum: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
export type BridgeFailoverConfigStateEnum = (typeof BridgeFailoverConfigStateEnum)[keyof typeof BridgeFailoverConfigStateEnum];
export declare const BridgeFailoverModeEnum: {
    readonly Failover: "FAILOVER";
};
export type BridgeFailoverModeEnum = (typeof BridgeFailoverModeEnum)[keyof typeof BridgeFailoverModeEnum];
export declare const BridgeOutputResourceBridgeNetworkOutputProtocol: {
    readonly RtpFec: "rtp-fec";
    readonly Rtp: "rtp";
    readonly Udp: "udp";
};
/**
 * The network output protocol.
 */
export type BridgeOutputResourceBridgeNetworkOutputProtocol = (typeof BridgeOutputResourceBridgeNetworkOutputProtocol)[keyof typeof BridgeOutputResourceBridgeNetworkOutputProtocol];
export declare const BridgeProtocolEnum: {
    readonly RtpFec: "rtp-fec";
    readonly Rtp: "rtp";
    readonly Udp: "udp";
};
export type BridgeProtocolEnum = (typeof BridgeProtocolEnum)[keyof typeof BridgeProtocolEnum];
export declare const BridgeSourceProtocolEnum: {
    readonly RtpFec: "rtp-fec";
    readonly Rtp: "rtp";
    readonly Udp: "udp";
};
export type BridgeSourceProtocolEnum = (typeof BridgeSourceProtocolEnum)[keyof typeof BridgeSourceProtocolEnum];
export declare const BridgeStateEnum: {
    readonly Creating: "CREATING";
    readonly Standby: "STANDBY";
    readonly Starting: "STARTING";
    readonly Deploying: "DEPLOYING";
    readonly Active: "ACTIVE";
    readonly Stopping: "STOPPING";
    readonly Deleting: "DELETING";
    readonly Deleted: "DELETED";
    readonly StartFailed: "START_FAILED";
    readonly StartPending: "START_PENDING";
    readonly Updating: "UPDATING";
};
export type BridgeStateEnum = (typeof BridgeStateEnum)[keyof typeof BridgeStateEnum];
export declare const FlowEncryptionAlgorithm: {
    readonly Aes128: "aes128";
    readonly Aes192: "aes192";
    readonly Aes256: "aes256";
};
/**
 * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
 */
export type FlowEncryptionAlgorithm = (typeof FlowEncryptionAlgorithm)[keyof typeof FlowEncryptionAlgorithm];
export declare const FlowEncryptionKeyType: {
    readonly Speke: "speke";
    readonly StaticKey: "static-key";
    readonly SrtPassword: "srt-password";
};
/**
 * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
 */
export type FlowEncryptionKeyType = (typeof FlowEncryptionKeyType)[keyof typeof FlowEncryptionKeyType];
export declare const FlowEntitlementEncryptionAlgorithm: {
    readonly Aes128: "aes128";
    readonly Aes192: "aes192";
    readonly Aes256: "aes256";
};
/**
 * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
 */
export type FlowEntitlementEncryptionAlgorithm = (typeof FlowEntitlementEncryptionAlgorithm)[keyof typeof FlowEntitlementEncryptionAlgorithm];
export declare const FlowEntitlementEncryptionKeyType: {
    readonly Speke: "speke";
    readonly StaticKey: "static-key";
};
/**
 * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
 */
export type FlowEntitlementEncryptionKeyType = (typeof FlowEntitlementEncryptionKeyType)[keyof typeof FlowEntitlementEncryptionKeyType];
export declare const FlowEntitlementEntitlementStatus: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 *  An indication of whether the entitlement is enabled.
 */
export type FlowEntitlementEntitlementStatus = (typeof FlowEntitlementEntitlementStatus)[keyof typeof FlowEntitlementEntitlementStatus];
export declare const FlowFailoverConfigFailoverMode: {
    readonly Merge: "MERGE";
    readonly Failover: "FAILOVER";
};
/**
 * The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
 */
export type FlowFailoverConfigFailoverMode = (typeof FlowFailoverConfigFailoverMode)[keyof typeof FlowFailoverConfigFailoverMode];
export declare const FlowFailoverConfigState: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
 */
export type FlowFailoverConfigState = (typeof FlowFailoverConfigState)[keyof typeof FlowFailoverConfigState];
export declare const FlowFmtpColorimetry: {
    readonly Bt601: "BT601";
    readonly Bt709: "BT709";
    readonly Bt2020: "BT2020";
    readonly Bt2100: "BT2100";
    readonly St20651: "ST2065-1";
    readonly St20653: "ST2065-3";
    readonly Xyz: "XYZ";
};
/**
 * The format used for the representation of color.
 */
export type FlowFmtpColorimetry = (typeof FlowFmtpColorimetry)[keyof typeof FlowFmtpColorimetry];
export declare const FlowFmtpRange: {
    readonly Narrow: "NARROW";
    readonly Full: "FULL";
    readonly Fullprotect: "FULLPROTECT";
};
/**
 * The encoding range of the video.
 */
export type FlowFmtpRange = (typeof FlowFmtpRange)[keyof typeof FlowFmtpRange];
export declare const FlowFmtpScanMode: {
    readonly Progressive: "progressive";
    readonly Interlace: "interlace";
    readonly ProgressiveSegmentedFrame: "progressive-segmented-frame";
};
/**
 * The type of compression that was used to smooth the video's appearance.
 */
export type FlowFmtpScanMode = (typeof FlowFmtpScanMode)[keyof typeof FlowFmtpScanMode];
export declare const FlowFmtpTcs: {
    readonly Sdr: "SDR";
    readonly Pq: "PQ";
    readonly Hlg: "HLG";
    readonly Linear: "LINEAR";
    readonly Bt2100linpq: "BT2100LINPQ";
    readonly Bt2100linhlg: "BT2100LINHLG";
    readonly St20651: "ST2065-1";
    readonly St4281: "ST428-1";
    readonly Density: "DENSITY";
};
/**
 * The transfer characteristic system (TCS) that is used in the video.
 */
export type FlowFmtpTcs = (typeof FlowFmtpTcs)[keyof typeof FlowFmtpTcs];
export declare const FlowMaintenanceMaintenanceDay: {
    readonly Monday: "Monday";
    readonly Tuesday: "Tuesday";
    readonly Wednesday: "Wednesday";
    readonly Thursday: "Thursday";
    readonly Friday: "Friday";
    readonly Saturday: "Saturday";
    readonly Sunday: "Sunday";
};
/**
 * A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
 */
export type FlowMaintenanceMaintenanceDay = (typeof FlowMaintenanceMaintenanceDay)[keyof typeof FlowMaintenanceMaintenanceDay];
export declare const FlowMediaStreamMediaStreamType: {
    readonly Video: "video";
    readonly Audio: "audio";
    readonly AncillaryData: "ancillary-data";
};
/**
 * The type of media stream.
 */
export type FlowMediaStreamMediaStreamType = (typeof FlowMediaStreamMediaStreamType)[keyof typeof FlowMediaStreamMediaStreamType];
export declare const FlowMediaStreamSourceConfigurationEncodingName: {
    readonly Jxsv: "jxsv";
    readonly Raw: "raw";
    readonly Smpte291: "smpte291";
    readonly Pcm: "pcm";
};
/**
 * The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
 */
export type FlowMediaStreamSourceConfigurationEncodingName = (typeof FlowMediaStreamSourceConfigurationEncodingName)[keyof typeof FlowMediaStreamSourceConfigurationEncodingName];
export declare const FlowMediaStreamVideoFormat: {
    readonly FlowMediaStreamVideoFormat_2160p: "2160p";
    readonly FlowMediaStreamVideoFormat_1080p: "1080p";
    readonly FlowMediaStreamVideoFormat_1080i: "1080i";
    readonly FlowMediaStreamVideoFormat_720p: "720p";
    readonly FlowMediaStreamVideoFormat_480p: "480p";
};
/**
 * The resolution of the video.
 */
export type FlowMediaStreamVideoFormat = (typeof FlowMediaStreamVideoFormat)[keyof typeof FlowMediaStreamVideoFormat];
export declare const FlowOutputEncodingParametersEncoderProfile: {
    readonly Main: "main";
    readonly High: "high";
};
/**
 * A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
 */
export type FlowOutputEncodingParametersEncoderProfile = (typeof FlowOutputEncodingParametersEncoderProfile)[keyof typeof FlowOutputEncodingParametersEncoderProfile];
export declare const FlowOutputEncryptionAlgorithm: {
    readonly Aes128: "aes128";
    readonly Aes192: "aes192";
    readonly Aes256: "aes256";
};
/**
 * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
 */
export type FlowOutputEncryptionAlgorithm = (typeof FlowOutputEncryptionAlgorithm)[keyof typeof FlowOutputEncryptionAlgorithm];
export declare const FlowOutputEncryptionKeyType: {
    readonly StaticKey: "static-key";
    readonly SrtPassword: "srt-password";
};
/**
 * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
 */
export type FlowOutputEncryptionKeyType = (typeof FlowOutputEncryptionKeyType)[keyof typeof FlowOutputEncryptionKeyType];
export declare const FlowOutputMediaStreamOutputConfigurationEncodingName: {
    readonly Jxsv: "jxsv";
    readonly Raw: "raw";
    readonly Smpte291: "smpte291";
    readonly Pcm: "pcm";
};
/**
 * The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video streams on sources or outputs that use the CDI protocol, set the encoding name to raw. For video streams on sources or outputs that use the ST 2110 JPEG XS protocol, set the encoding name to jxsv.
 */
export type FlowOutputMediaStreamOutputConfigurationEncodingName = (typeof FlowOutputMediaStreamOutputConfigurationEncodingName)[keyof typeof FlowOutputMediaStreamOutputConfigurationEncodingName];
export declare const FlowOutputOutputStatus: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * An indication of whether the output should transmit data or not.
 */
export type FlowOutputOutputStatus = (typeof FlowOutputOutputStatus)[keyof typeof FlowOutputOutputStatus];
export declare const FlowOutputProtocol: {
    readonly ZixiPush: "zixi-push";
    readonly RtpFec: "rtp-fec";
    readonly Rtp: "rtp";
    readonly ZixiPull: "zixi-pull";
    readonly Rist: "rist";
    readonly FujitsuQos: "fujitsu-qos";
    readonly SrtListener: "srt-listener";
    readonly SrtCaller: "srt-caller";
    readonly St2110Jpegxs: "st2110-jpegxs";
    readonly Cdi: "cdi";
};
/**
 * The protocol that is used by the source or output.
 */
export type FlowOutputProtocol = (typeof FlowOutputProtocol)[keyof typeof FlowOutputProtocol];
export declare const FlowSourceEncryptionAlgorithm: {
    readonly Aes128: "aes128";
    readonly Aes192: "aes192";
    readonly Aes256: "aes256";
};
/**
 * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
 */
export type FlowSourceEncryptionAlgorithm = (typeof FlowSourceEncryptionAlgorithm)[keyof typeof FlowSourceEncryptionAlgorithm];
export declare const FlowSourceEncryptionKeyType: {
    readonly Speke: "speke";
    readonly StaticKey: "static-key";
    readonly SrtPassword: "srt-password";
};
/**
 * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
 */
export type FlowSourceEncryptionKeyType = (typeof FlowSourceEncryptionKeyType)[keyof typeof FlowSourceEncryptionKeyType];
export declare const FlowSourceMonitoringConfigThumbnailState: {
    readonly Enabled: "ENABLED";
    readonly Disabled: "DISABLED";
};
/**
 * The state of thumbnail monitoring.
 */
export type FlowSourceMonitoringConfigThumbnailState = (typeof FlowSourceMonitoringConfigThumbnailState)[keyof typeof FlowSourceMonitoringConfigThumbnailState];
export declare const FlowSourceProtocol: {
    readonly ZixiPush: "zixi-push";
    readonly RtpFec: "rtp-fec";
    readonly Rtp: "rtp";
    readonly Rist: "rist";
    readonly FujitsuQos: "fujitsu-qos";
    readonly SrtListener: "srt-listener";
    readonly SrtCaller: "srt-caller";
    readonly St2110Jpegxs: "st2110-jpegxs";
    readonly Cdi: "cdi";
};
/**
 * The protocol that is used by the source.
 */
export type FlowSourceProtocol = (typeof FlowSourceProtocol)[keyof typeof FlowSourceProtocol];
export declare const FlowVpcInterfaceNetworkInterfaceType: {
    readonly Ena: "ena";
    readonly Efa: "efa";
};
/**
 * The type of network adapter that you want MediaConnect to use on this interface. If you don't set this value, it defaults to ENA.
 */
export type FlowVpcInterfaceNetworkInterfaceType = (typeof FlowVpcInterfaceNetworkInterfaceType)[keyof typeof FlowVpcInterfaceNetworkInterfaceType];
export declare const GatewayState: {
    readonly Creating: "CREATING";
    readonly Active: "ACTIVE";
    readonly Updating: "UPDATING";
    readonly Error: "ERROR";
    readonly Deleting: "DELETING";
    readonly Deleted: "DELETED";
};
/**
 * The current status of the gateway.
 */
export type GatewayState = (typeof GatewayState)[keyof typeof GatewayState];
