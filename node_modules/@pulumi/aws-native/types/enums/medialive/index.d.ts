export declare const ChannelPlacementGroupState: {
    readonly Unassigned: "UNASSIGNED";
    readonly Assigning: "ASSIGNING";
    readonly Assigned: "ASSIGNED";
    readonly Deleting: "DELETING";
    readonly Deleted: "DELETED";
    readonly Unassigning: "UNASSIGNING";
};
/**
 * The current state of the ChannelPlacementGroupState
 */
export type ChannelPlacementGroupState = (typeof ChannelPlacementGroupState)[keyof typeof ChannelPlacementGroupState];
export declare const CloudWatchAlarmTemplateComparisonOperator: {
    readonly GreaterThanOrEqualToThreshold: "GreaterThanOrEqualToThreshold";
    readonly GreaterThanThreshold: "GreaterThanThreshold";
    readonly LessThanThreshold: "LessThanThreshold";
    readonly LessThanOrEqualToThreshold: "LessThanOrEqualToThreshold";
};
/**
 * The comparison operator used to compare the specified statistic and the threshold.
 */
export type CloudWatchAlarmTemplateComparisonOperator = (typeof CloudWatchAlarmTemplateComparisonOperator)[keyof typeof CloudWatchAlarmTemplateComparisonOperator];
export declare const CloudWatchAlarmTemplateStatistic: {
    readonly SampleCount: "SampleCount";
    readonly Average: "Average";
    readonly Sum: "Sum";
    readonly Minimum: "Minimum";
    readonly Maximum: "Maximum";
};
/**
 * The statistic to apply to the alarm's metric data.
 */
export type CloudWatchAlarmTemplateStatistic = (typeof CloudWatchAlarmTemplateStatistic)[keyof typeof CloudWatchAlarmTemplateStatistic];
export declare const CloudWatchAlarmTemplateTargetResourceType: {
    readonly CloudfrontDistribution: "CLOUDFRONT_DISTRIBUTION";
    readonly MedialiveMultiplex: "MEDIALIVE_MULTIPLEX";
    readonly MedialiveChannel: "MEDIALIVE_CHANNEL";
    readonly MedialiveInputDevice: "MEDIALIVE_INPUT_DEVICE";
    readonly MediapackageChannel: "MEDIAPACKAGE_CHANNEL";
    readonly MediapackageOriginEndpoint: "MEDIAPACKAGE_ORIGIN_ENDPOINT";
    readonly MediaconnectFlow: "MEDIACONNECT_FLOW";
    readonly S3Bucket: "S3_BUCKET";
};
/**
 * The resource type this template should dynamically generate cloudwatch metric alarms for.
 */
export type CloudWatchAlarmTemplateTargetResourceType = (typeof CloudWatchAlarmTemplateTargetResourceType)[keyof typeof CloudWatchAlarmTemplateTargetResourceType];
export declare const CloudWatchAlarmTemplateTreatMissingData: {
    readonly NotBreaching: "notBreaching";
    readonly Breaching: "breaching";
    readonly Ignore: "ignore";
    readonly Missing: "missing";
};
/**
 * Specifies how missing data points are treated when evaluating the alarm's condition.
 */
export type CloudWatchAlarmTemplateTreatMissingData = (typeof CloudWatchAlarmTemplateTreatMissingData)[keyof typeof CloudWatchAlarmTemplateTreatMissingData];
export declare const ClusterState: {
    readonly Creating: "CREATING";
    readonly CreateFailed: "CREATE_FAILED";
    readonly Active: "ACTIVE";
    readonly Deleting: "DELETING";
    readonly Deleted: "DELETED";
};
/**
 * The current state of the Cluster.
 */
export type ClusterState = (typeof ClusterState)[keyof typeof ClusterState];
export declare const ClusterType: {
    readonly OnPremises: "ON_PREMISES";
    readonly OutpostsRack: "OUTPOSTS_RACK";
    readonly OutpostsServer: "OUTPOSTS_SERVER";
    readonly Ec2: "EC2";
};
/**
 * The hardware type for the cluster.
 */
export type ClusterType = (typeof ClusterType)[keyof typeof ClusterType];
export declare const EventBridgeRuleTemplateEventType: {
    readonly MedialiveMultiplexAlert: "MEDIALIVE_MULTIPLEX_ALERT";
    readonly MedialiveMultiplexStateChange: "MEDIALIVE_MULTIPLEX_STATE_CHANGE";
    readonly MedialiveChannelAlert: "MEDIALIVE_CHANNEL_ALERT";
    readonly MedialiveChannelInputChange: "MEDIALIVE_CHANNEL_INPUT_CHANGE";
    readonly MedialiveChannelStateChange: "MEDIALIVE_CHANNEL_STATE_CHANGE";
    readonly MediapackageInputNotification: "MEDIAPACKAGE_INPUT_NOTIFICATION";
    readonly MediapackageKeyProviderNotification: "MEDIAPACKAGE_KEY_PROVIDER_NOTIFICATION";
    readonly MediapackageHarvestJobNotification: "MEDIAPACKAGE_HARVEST_JOB_NOTIFICATION";
    readonly SignalMapActiveAlarm: "SIGNAL_MAP_ACTIVE_ALARM";
    readonly MediaconnectAlert: "MEDIACONNECT_ALERT";
    readonly MediaconnectSourceHealth: "MEDIACONNECT_SOURCE_HEALTH";
    readonly MediaconnectOutputHealth: "MEDIACONNECT_OUTPUT_HEALTH";
    readonly MediaconnectFlowStatusChange: "MEDIACONNECT_FLOW_STATUS_CHANGE";
};
/**
 * The type of event to match with the rule.
 */
export type EventBridgeRuleTemplateEventType = (typeof EventBridgeRuleTemplateEventType)[keyof typeof EventBridgeRuleTemplateEventType];
export declare const MultiplexState: {
    readonly Creating: "CREATING";
    readonly CreateFailed: "CREATE_FAILED";
    readonly Idle: "IDLE";
    readonly Starting: "STARTING";
    readonly Running: "RUNNING";
    readonly Recovering: "RECOVERING";
    readonly Stopping: "STOPPING";
    readonly Deleting: "DELETING";
    readonly Deleted: "DELETED";
};
/**
 * The current state of the multiplex.
 */
export type MultiplexState = (typeof MultiplexState)[keyof typeof MultiplexState];
export declare const MultiplexprogramPreferredChannelPipeline: {
    readonly CurrentlyActive: "CURRENTLY_ACTIVE";
    readonly Pipeline0: "PIPELINE_0";
    readonly Pipeline1: "PIPELINE_1";
};
/**
 * Indicates which pipeline is preferred by the multiplex for program ingest.
 * If set to \"PIPELINE_0\" or \"PIPELINE_1\" and an unhealthy ingest causes the multiplex to switch to the non-preferred pipeline,
 * it will switch back once that ingest is healthy again. If set to \"CURRENTLY_ACTIVE\",
 * it will not switch back to the other pipeline based on it recovering to a healthy state,
 * it will only switch if the active pipeline becomes unhealthy.
 */
export type MultiplexprogramPreferredChannelPipeline = (typeof MultiplexprogramPreferredChannelPipeline)[keyof typeof MultiplexprogramPreferredChannelPipeline];
export declare const NetworkState: {
    readonly Creating: "CREATING";
    readonly CreateFailed: "CREATE_FAILED";
    readonly Active: "ACTIVE";
    readonly Deleting: "DELETING";
    readonly Idle: "IDLE";
    readonly InUse: "IN_USE";
    readonly Updating: "UPDATING";
    readonly Deleted: "DELETED";
    readonly DeleteFailed: "DELETE_FAILED";
};
export type NetworkState = (typeof NetworkState)[keyof typeof NetworkState];
export declare const SdiSourceMode: {
    readonly Quadrant: "QUADRANT";
    readonly Interleave: "INTERLEAVE";
};
/**
 * The current state of the SdiSource.
 */
export type SdiSourceMode = (typeof SdiSourceMode)[keyof typeof SdiSourceMode];
export declare const SdiSourceState: {
    readonly Idle: "IDLE";
    readonly InUse: "IN_USE";
    readonly Deleted: "DELETED";
};
/**
 * The current state of the SdiSource.
 */
export type SdiSourceState = (typeof SdiSourceState)[keyof typeof SdiSourceState];
export declare const SdiSourceType: {
    readonly Single: "SINGLE";
    readonly Quad: "QUAD";
};
/**
 * The interface mode of the SdiSource.
 */
export type SdiSourceType = (typeof SdiSourceType)[keyof typeof SdiSourceType];
export declare const SignalMapMonitorDeploymentStatus: {
    readonly NotDeployed: "NOT_DEPLOYED";
    readonly DryRunDeploymentComplete: "DRY_RUN_DEPLOYMENT_COMPLETE";
    readonly DryRunDeploymentFailed: "DRY_RUN_DEPLOYMENT_FAILED";
    readonly DryRunDeploymentInProgress: "DRY_RUN_DEPLOYMENT_IN_PROGRESS";
    readonly DeploymentComplete: "DEPLOYMENT_COMPLETE";
    readonly DeploymentFailed: "DEPLOYMENT_FAILED";
    readonly DeploymentInProgress: "DEPLOYMENT_IN_PROGRESS";
    readonly DeleteComplete: "DELETE_COMPLETE";
    readonly DeleteFailed: "DELETE_FAILED";
    readonly DeleteInProgress: "DELETE_IN_PROGRESS";
};
/**
 * A signal map's monitor deployment status.
 */
export type SignalMapMonitorDeploymentStatus = (typeof SignalMapMonitorDeploymentStatus)[keyof typeof SignalMapMonitorDeploymentStatus];
export declare const SignalMapStatus: {
    readonly CreateInProgress: "CREATE_IN_PROGRESS";
    readonly CreateComplete: "CREATE_COMPLETE";
    readonly CreateFailed: "CREATE_FAILED";
    readonly UpdateInProgress: "UPDATE_IN_PROGRESS";
    readonly UpdateComplete: "UPDATE_COMPLETE";
    readonly UpdateReverted: "UPDATE_REVERTED";
    readonly UpdateFailed: "UPDATE_FAILED";
    readonly Ready: "READY";
    readonly NotReady: "NOT_READY";
};
/**
 * A signal map's current status which is dependent on its lifecycle actions or associated jobs.
 */
export type SignalMapStatus = (typeof SignalMapStatus)[keyof typeof SignalMapStatus];
